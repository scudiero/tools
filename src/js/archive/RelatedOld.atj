//=================================================================================================
// Add related departments/colleges/schools to the workflow,
// returned data is sorted by code and duplicates are removed.
//=================================================================================================
// Variable definitions:
//		form fields that contain 'related/crosslisted/associated/consultant' data.  formate is name|format
// 		where formate is one item in the set {code,dept,subj}. RelatedVar may be repeated as necessary.
// 		RelatedVar:<Form variable name 1><|format for var 1>
//		e.g.
// 		RelatedVar:crosslisted|code
// 		RelatedVar:consultdept|dept
//
// Global switches/flags:
//		Check to see if the primary Dept or Subject values have change, if yes include.  Default is 'No'
// 		RelatedCheckChanged:<Yes/No>
//		Incorporate the data from the eco system into the output, if yes include.  Default is 'No'
// 		RelatedIncludeEcoSystemData:<Yes/No>
//
// Eco system data:
//		If retrieving data from the eco system option you may define which references types to use.
//		Field may be repeaded as necessary.
//		RelatedFromEcoSystemType:<refType>
//		e.g.
//		RelatedFromEcoSystemType:equiv
//
// Rule definitions:
// 		wfrule definition defines what data to be include in workflow:
// 			if the lower(rule name) includes 'dept' then substitute the department value into step
// 			if the lower(rule name) includes 'school' then substitute the school value into step
// 			if the lower(rule name) includes 'college' then substitute the college value into step
// 		for each returned token
// 		wfrules:<somePrefixTerm>Depts|function|Crosslisted|
// 		wfrules:<somePrefixTerm>Schools|function|Crosslisted|
// 		wfrules:<somePrefixTerm>Colleges|function|Crosslisted|
//		e.g.
//		wfrules:RelatedDepts|function|Related|
//		wfrules:RelatedCols|function|Related|
//
// Step definitinos one for each definition above:
//		If defined , these will be the steps include in the workflow for each rule name type above.
//		If not defined then the step data will be taken from the step usage in the workflow itself.
//		e.g.
//		RelatedDeptsSteps:Dept Courses Committee fyi optional
// 		RelatedDeptsSteps:Dept Courses Committee Chair fyi optional
// 		RelatedDeptsSteps:Dept Head optional
// 		RelatedCollegeSteps:Col Curriculum Committee fyi optional
// 		RelatedCollegeSteps:Col Curriculum Committee Chair fyi optional
//		RelatedCollegeSteps:Col Dean optional
//=================================================================================================

wffuncs.Related = function(inval, wfrule, args) {
	var version='4.0';
	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug) { Debug('\n*** In '+ myName + " called as '" + wfrule.searchfor + "' ***"); Dump('\tFunction version',version); }
	if (haveDebug) { Dump('\tFull Step text',inval); }
	//if (haveDebug) { Dump('\targs',args.toSource()); Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); }

	// Determin mode (dept / college) based on the mapped name
		var notifyMode=false;
		var hasSchool=false;
		var reqType=wfrule.searchfor.toLowerCase();
		if (reqType.substr(reqType.length - 'notify'.length) == 'notify') {
			notifyMode=true;
		}
		if (haveDebug) { Dump('\treqType',reqType); Dump('\tnotifyMode',notifyMode);}

	//Set switches from tcfdata in config file
		var checkChanged=false;
		if (tcfdata.RelatedCheckChanged && tcfdata.RelatedCheckChanged.length > 0)
			checkChanged=tcfdata.RelatedCheckChanged[0].substr(0,1).toLowerCase();
		if (haveDebug) { Dump('\tcheckChanged',checkChanged); }

		var includeEcoSystemData=false;
		if (tcfdata.RelatedIncludeEcoSystemData && tcfdata.RelatedIncludeEcoSystemData.length > 0) {
			includeEcoSystemData=tcfdata.RelatedIncludeEcoSystemData[0].substr(0,1).toLowerCase();
			if (includeEcoSystemData === 'y' || includeEcoSystemData === 't') {
				var ecoSystemType=[];
				if (tcfdata.RelatedFromEcoSystemType && tcfdata.RelatedFromEcoSystemType.length > 0) {
					ecoSystemType=tcfdata.RelatedFromEcoSystemType
					var ecoSystemTypeStr='';
					ecoSystemType.forEach(function(type) {
						ecoSystemTypeStr=ecoSystemTypeStr + ",'" + type + "'";
					});
					ecoSystemTypeStr='(' + ecoSystemTypeStr.substring(1) + ')';
				}
				if (haveDebug) { Dump('\tecoSystemTypeStr',ecoSystemTypeStr); }
				includeEcoSystemData=true;
			} else { includeEcoSystemData=false; }
		}
		if (haveDebug) { Dump('\tincludeEcoSystemData',includeEcoSystemData); Debug(''); }

	//Set options from tcfdata in config file
		var relatedVar=[];
		if (tcfdata.RelatedVar && tcfdata.RelatedVar.length > 0)
			relatedVar=tcfdata.RelatedVar
		if (haveDebug) { Dump('\trelatedVar',relatedVar.toSource()); }

	//Try block encapsulated main function
	try {
		// initial checks
			if (args && args.context && args.context != "wfrule")
				throw 'Failed rule type check';
			if (!tcfdata.code || !tcfdata.code.length)
				throw 'Failed code not null check';
			if (!tcfdata.subject || !tcfdata.subject.length)
				throw 'Failed subject not null check';
			if (!tcfdata.department || !tcfdata.department.length)
				throw 'Failed department not null check';
			if (!tcfdata.college || !tcfdata.college.length)
				throw 'Failed college not null check';

		// Get proposal data
			var parentCode=tcfdata.code[0];
			var parentSubj=tcfdata.subject[0].code;
			var parentDept=tcfdata.department[0].code;
			var parentCol=tcfdata.college[0].code;
			if (haveDebug) { Dump('\tparentCode',parentCode); Dump('\tparentSubj',parentSubj); Dump('\tparentDept',parentDept); Dump('\tparentCol',parentCol); }

			// If request type is school then lookup school code
			if (reqType.indexOf('school') > 0) {
				hasSchool=true;
				// Lookup parent school
				var parentSchool='';
				sql='SELECT school FROM cimlookup WHERE department=? and college=?';
				sqlParms=[parentDept,parentCol];
				rows=dbquery(tcfdata.dbname[0],sql,sqlParms);
				if (rows.length >0 ) {
					parentSchool=rows[0].school;
				}
				if (haveDebug) { Dump('\tparentschool',parentSchool); }
			}

		//==================================================================================================
		// MAIN
		//==================================================================================================
		var ref={};
		// loop through form data variables, pull data and set refs array
			var refsArray=[];
			var refsLookup={};
			var formVar, formVarFormat;
			relatedVar.forEach(function(formVar) {
				var tmpArray=formVar.split('|');
				formVar=tmpArray[0];
				formVarFormat='c'
				// Parse off formVar name and optional forVar format (i.e. formVarName|formVarFormat) 
				if (tmpArray.length > 1) {
					formVarFormat=tmpArray[1];
					var tempStr=formVarFormat.toLowerCase().substr(0,1);
					formVarFormat=tempStr
				}
				if (haveDebug) { Debug("\n\tProcessing form variable: '" + formVar + "'"); Debug("\t\tformat: '" + formVarFormat + "'...");}

				var tcfData=[];
				tcfData=eval('tcfdata.'+formVar); // jshint ignore:line
				if (typeof(tcfData) === 'undefined') {
					Debug('\t\t*** Variable ' + formVar + ' is not defined in the tcf file, skipping');
					return;
				}
				if (haveDebug) { Dump('\t\ttcfData',tcfData.toSource()); }

				var tcaData=[];
				if (typeof eval('tcadata.'+formVar) != 'undefined' )
					tcaData=eval('tcadata.'+formVar); // jshint ignore:line
				if (haveDebug) { Dump('\t\ttcaData',tcaData.toSource()); }

				// Make a has table of the related data
				tcfData.forEach(function(data) {
					ref={};
					if (formVarFormat === 'c') { // format=code
						var tempArray=data.code.split(' ');
						ref.data=tempArray[0];
						ref.format='subj';
					} else if (formVarFormat === 'd') { // format=dept
						ref.data=data.code;
						ref.dept=data.code
						ref.format='dept';
					} else if (formVarFormat === 's') { // format=subj
						ref.data=data.code;
						ref.format='subj';
					}
					if (ref != {}) {
						ref.source=formVar;
						if (haveDebug) { Dump('\t\tref',ref.toSource()); }
						refsArray.push(ref);
					}
					refsLookup[data.toSource()]=refsArray.length-1;
				}); //tcfData
				//if (haveDebug) { Dump('\t\trefsArray',refsArray.toSource());Dump('\t\trefsLookup',refsLookup.toSource()); }

				// Scan the tca data and see if there are any elements not in the tcf data, i.e. it has been deleted
				tcaData.forEach(function(b) {
					if (refsLookup[b.toSource()] === undefined) {
						if (haveDebug) {Debug("\t\tAdding deleted code to refsArray: " + b.toSource());}
						refsArray.push(b);
					}
				}); //tcfData

				// Check to see if the subject code has change, if yes then include the origional subject code in the refsArray
					if (tcadata.subject && tcadata.subject.length > 0) {
						if (tcadata.subject[0].code != parentSubj) {
							if (haveDebug) { Debug('\tSubject code changed, adding origional (from tca): ' + tcadata.subject[0].code);}
							refsArray.push({code:tcadata.subject[0].code});
						}
					}
				// Check to see if the department code has change, if yes then include the origional subject code in the refsArray
					if (tcadata.department && tcadata.department.length > 0) {
						if (tcadata.department[0].code != parentDept) {
							if (haveDebug) { Debug('\tDepartment code changed, adding origional (from tca): ' + tcadata.department[0].code);}
							refsArray.push({department:tcadata.department[0].code});
						}
					}
				//if (haveDebug) { Dump('\t\trefsArray',refsArray.toSource()); }
			}); //relatedVar

		var sqlStmt, sqlParms, resultSet=[];
		//Check for any cross references data for this course in the crossref table (eco system)
			if (includeEcoSystemData) {
				if (haveDebug) { Debug("\n\tRetrieving data from the eco system...");}
				// Get referenced dept data from courseref, parse path to find out type of reference and add to refsArray
					sqlStmt="SELECT DISTINCT path,dept FROM courseref WHERE code = ? AND dept <> ? AND dept <> ''";
					if (typeof(ecoSystemTypeStr) != 'undefined'  )
						sqlStmt=sqlStmt + ' AND type IN ' + ecoSystemTypeStr
					sqlParms=[parentCode,parentDept];
					resultSet=dbquery("courseref", sqlStmt,sqlParms);
					if (haveDebug) { Debug('\t\tCourseref query returned ' + resultSet.length + ' records.'); }
					resultSet.forEach(function(result) {
						//if (haveDebug) { Dump('\nresult',result.toSource()); }
						ref={};
						if (result.path.substr(0,1) === '/' || result.path.substr(0,12) === 'programcode:') { // i.e. a catalog or programadmin ref
							if (result.dept != parentDept) {
								ref.data=result.dept;
								ref.dept=result.dept;
								ref.format='dept';
							}
						} else { // i.e. a course ref
							ref.data=result.dept;
							ref.format='subj';
						}
						if (typeof ref.data != 'undefined') {
							ref.source='eco:'+ result.path.substr(0,1);
							refsArray.push(ref);
							if (haveDebug) { Debug("\t\t\t" + ref.toSource());}
						}
					}); //resultSet
			} //includeEcoSystemData

			if (refsArray.length === 0) {
				if (haveDebug) { Debug("\t*** Zero (0) items to add");}
				return false;
			}

		// Look up the output tokens based on how we were called (Dept, Col, School)
			//if (haveDebug) { Debug("\n\tRetrieving data from the eco system...");}
			var outTokens=[], steps=[]

			refsArray.forEach(function(ref) {
				//if (haveDebug) { Dump('\t\tref',ref.toSource()); }
				sqlStmt='';
				if (reqType.indexOf('depts') > 0) {
					searchStr='Dept';
					if (tcfdata.CrosslistedDeptsSteps && tcfdata.CrosslistedDeptsSteps.length > 0)
						steps=tcfdata.CrosslistedDeptsSteps;
					if (ref.format === 'dept' ) {
						outTokens.push(ref.dept);
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct department as token FROM cimlookup WHERE subject=? and department <> ?";
						sqlParms=[ref.data,parentDept];
					}

				} else if (reqType.indexOf('colleges') > 0) {
					searchStr='Col'
					if (tcfdata.CrosslistedCollegesSteps && tcfdata.CrosslistedCollegesSteps.length > 0)
						steps=tcfdata.CrosslistedCollegesSteps;
					if (ref.format === 'dept' ) {
						sqlStmt="SELECT distinct college as token FROM cimlookup WHERE department=?";
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct college as token FROM cimlookup WHERE subject=?";
					}
					sqlParms=[ref.data];
				} else if (reqType.indexOf('schools') > 0) {
					searchStr='School'
					if (tcfdata.CrosslistedSchoolsSteps && tcfdata.CrosslistedSchoolsSteps.length > 0)
						steps=tcfdata.CrosslistedSchoolsSteps;
					if (ref.format === 'dept' ) {
						sqlStmt="SELECT distinct school as token FROM cimlookup WHERE department=?";
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct school as token FROM cimlookup WHERE subject=?";
					}
					sqlParms=[ref.data];
				}
				if (sqlStmt != '') {
					resultSet=dbquery("cimcourses",sqlStmt,sqlParms);
					resultSet.forEach(function(result) {
						//if (haveDebug) { Dump('\t\t\ttoken',result.token); }
						outTokens.push(result.token);
					});
				}
			}); //refsArray

			outTokens=RemoveDupes(outTokens);
			if (haveDebug) {
				Debug('\n\tOutput tokens (' + searchStr + '):');for (var key in outTokens) { Dump('\t\toutTokens[' + key + ']',outTokens[key].toSource()); }('');
				if (steps.length > 0)
					Debug('\n\tSteps defined in config file:');for (var key in steps) { Dump('\t\tsteps[' + key + ']',steps[key].toSource()); }(''); 
			}

		// Output the steps
			var retArray=[];
			if (haveDebug) { Debug("\n\tReturn step data for " + outTokens.length + " " + searchStr + "(s)...");}
			if (EnvIs('dev'))
				if (typeof tcfdata.debugDev != "undefined")
					if (tcfdata.debugDev === 'true') 
						retArray.push('*** START of ' + inval.toLowerCase().replace('optional','') + ' ***');


			outTokens.forEach(function(token) {
				if (token === '') return;
				if (inval == wfrule.searchfor) {
					steps.forEach(function(step) {
						step=step.replace(searchStr,token);
						if(notifyMode) {
							if (step.indexOf(' fyi') < 0) {
								step=step + ' fyiall';
							} else if (step.indexOf(' fyi') >= 0) {
								step=step.replace(' fyi',' fyiall');
							}
						}
						retArray.push(step.trim());
						Dump('\t\tReturning step: ',retArray[retArray.length-1]);
					});	//steps
				} else {
					retArray.push(inval.replace(wfrule.regex,token).trim());
					Dump('\t\tStep: ',retArray[retArray.length-1]);
				}
			}); //outTokens
			if (EnvIs('dev'))
				if (typeof tcfdata.debugDev != "undefined")
					if (tcfdata.debugDev === 'true') 
						retArray.push('*** END of ' + inval.toLowerCase().replace('optional','') + ' ***');

		return retArray;
	} //try

	//Catch block for errors thrown in above try block
	catch(err) { if (haveDebug) { Debug(err); } else { throw myName + ': ' + err; } return false; }

	// Should never get here
	return false;
}; //Related
