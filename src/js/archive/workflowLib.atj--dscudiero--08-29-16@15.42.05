//==================================================================================================
// version:1.5.29 // -- dscudiero -- 07/29/2016 @  7:34:57.87
//==================================================================================================
// Common wf functions and helper functions to support workflow
//==================================================================================================
if (typeof wffoundDebugEnv === 'undefined') { print_debug(">>> Loading %progdir%/localsteps/workflowLib.atj\n"); wfFoundDebugEnv=true; }

//==================================================================================================
//==================================================================================================
// Common wffuncs
//==================================================================================================
//==================================================================================================

//=================================================================================================
// Return additional steps for all 'equiv' courses in courseref table
//=================================================================================================
wffuncs.AddSameAs = function(inval, wfrule, args) {
	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug) Debug('\n*** In '+ myName + " called as '" + wfrule.searchfor + ", Step: '" + inval +"' ***");
	//if (haveDebug) { Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); }

	var retArray=[];
	//Try block encapsulated main function
	 try {
		// Initial Checks
			if(args && args.context && args.context != "wfrule")
		 		throw "\t*** Failed rule type check";
			if(!tcfdata.code || !tcfdata.code.length)
		 		throw "\t*** Failed tcfdata.code is not null check";
			if(!tcfdata.department || !tcfdata.department.length)
		 		throw "\t*** Failed tcfdata.department is not null check";
			if(!tcfdata.college || !tcfdata.college.length)
		 		throw "\t*** Failed tcfdata.college is not null check";

	 	// Main
			var reqType=wfrule.searchfor.toLowerCase();

			// Get proposal data
				var parentCode=tcfdata.code[0];
				var parentSubj=tcfdata.subject[0].code;
				var parentDept=tcfdata.department[0].code;
				var parentCol=tcfdata.college[0].code;
				if (haveDebug) { Dump('reqType',reqType); Dump('parentCode',parentCode); Dump('parentCol',parentCol); Dump('parentDept',parentDept); }

			// Lookup the equiv course from coursref
			var refSubj;
			sqlStmt="SELECT DISTINCT path,dept FROM courseref WHERE code = ? AND dept <> ? AND dept <> '' and type = 'equiv'";
			sqlParms=[parentCode,parentDept];
			resultSet1=dbquery("courseref",sqlStmt,sqlParms);
			resultSet1.forEach(function(courserefResult) {
				if (haveDebug) { Debug('\t Equiv result = >' + courserefResult.toSource() + '<\n'); }
				refSubj=courserefResult.dept;
				if (haveDebug) { Dump('\t\t refSubj',refSubj); }
				if (reqType.indexOf('depts') > 0) {
					sqlStmt="SELECT DISTINCT department 'token' FROM cimlookup WHERE subject = ? AND department <> ? AND department <> ''";
					sqlParms=[refSubj,parentDept];
				} else {
					sqlStmt="SELECT DISTINCT college as 'token' FROM cimlookup WHERE subject = ? AND college <> ? AND college <> ''";
					sqlParms=[refSubj,parentCol];
				}
				//print_debug('\t\t sqlStmt = >' + sqlStmt + '<\n');
				resultSet2=dbquery("cimcourses",sqlStmt,sqlParms);
				resultSet2.forEach(function(cimlookupResult) {
					if (haveDebug) { Dump('cimlookupResult',cimlookupResult.toSource()); }
					retArray.push(inval.replace(wfrule.regex,cimlookupResult.token))
				}); //resultSet2
			}); //resultSet1

		// return steps if found or false if none added
		if (retArray.length > 0) {
			if (haveDebug) { retArray.forEach(function(step) { print_debug('\t Returning step:  >' + step + '<\n'); }); }
			return retArray;
		} else {
			return false;
		}

	} //Try block
	//Catch block for errors thrown in above try block
	catch(err) { print_debug(wfrule.attrname + ": " + err) ; return false; }
	return false;  // Should never get here
} //AddSameAs

//=================================================================================================
// Add related departments/colleges/schools to the workflow,
// returned data is sorted by code and duplicates are removed.
//=================================================================================================
// Variable definitions:
//		form fields that contain 'related/crosslisted/associated/consultant' data.  formate is name|format|attrName
// 		where format is one item in the set {code,dept,subj}, the default is 'code'
// 		where attrName is the name of the object property that contains the related data, e.g 'code' or 'detail', the default is 'code'
// 		i.e. RelatedVar:<Form variable name 1><|format for var 1><|attribuate name for var 1>
//		RelatedVar may be repeated as necessary.
//		e.g.
// 		RelatedVar:crosslisted|code
// 		RelatedVar:crosslisted|code|detail
// 		RelatedVar:consultdept|dept
//
// Global switches/flags:
//		Check to see if the primary Dept or Subject values have change, if yes include.  Default is 'No'
// 		i.e. RelatedCheckChanged:<Yes/No>
//		Incorporate the data from the eco system into the output, if yes include.  Default is 'No'
// 		RelatedIncludeEcoSystemData:<Yes/No>
//
// Eco system data:
//		If retrieving data from the eco system option you may define which references types to use.
//		Field may be repeaded as necessary.
//		RelatedFromEcoSystemType:<refType>
//		e.g.
//		RelatedFromEcoSystemType:equiv
//
// Rule definitions:
// 		wfrule definition defines what data to be include in workflow:
// 			if the lower(rule name) includes 'dept' then substitute the department value into step
// 			if the lower(rule name) includes 'school' then substitute the school value into step
// 			if the lower(rule name) includes 'college' then substitute the college value into step
// 		for each returned token
// 		wfrules:<somePrefixTerm>Depts|function|Crosslisted|
// 		wfrules:<somePrefixTerm>Schools|function|Crosslisted|
// 		wfrules:<somePrefixTerm>Colleges|function|Crosslisted|
//		e.g.
//		wfrules:RelatedDepts|function|Related|
//		wfrules:RelatedCols|function|Related|
//
// Step definitinos one for each definition above:
//		If defined , these will be the steps include in the workflow for each rule name type above.
//		If not defined then the step data will be taken from the step usage in the workflow itself.
//		e.g.
//		RelatedDeptsSteps:Dept Courses Committee fyi optional
// 		RelatedDeptsSteps:Dept Courses Committee Chair fyi optional
// 		RelatedDeptsSteps:Dept Head optional
// 		RelatedCollegeSteps:Col Curriculum Committee fyi optional
// 		RelatedCollegeSteps:Col Curriculum Committee Chair fyi optional
//		RelatedCollegeSteps:Col Dean optional
//=================================================================================================
wffuncs.Related = function(inval, wfrule, args) {
	var version='4.0';
	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug) { Debug('\n*** In '+ myName + " called as '" + wfrule.searchfor + "' ***"); Dump('\tFunction version',version); }
	if (haveDebug) { Dump('\tFull Step text',inval); }
	//if (haveDebug) { Dump('\targs',args.toSource()); Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); }

	// Determin mode (dept / college) based on the mapped name
		var notifyMode=false;
		var hasSchool=false;
		var reqType=wfrule.searchfor.toLowerCase();
		if (reqType.substr(reqType.length - 'notify'.length) == 'notify') {
			notifyMode=true;
		}
		if (haveDebug) { Dump('\treqType',reqType); Dump('\tnotifyMode',notifyMode);}

	//Set switches from tcfdata in config file
		var checkChanged=false;
		if (tcfdata.RelatedCheckChanged && tcfdata.RelatedCheckChanged.length > 0)
			checkChanged=tcfdata.RelatedCheckChanged[0].substr(0,1).toLowerCase();
		if (haveDebug) { Dump('\tcheckChanged',checkChanged); }

		var includeEcoSystemData=false;
		if (tcfdata.RelatedIncludeEcoSystemData && tcfdata.RelatedIncludeEcoSystemData.length > 0) {
			if (tcfdata.RelatedIncludeEcoSystemData[0].substr(0,1).toLowerCase() === 'y') {
				includeEcoSystemData=true
			} else {
				if (tcfdata.RelatedIncludeEcoSystemData[0] === 'true') {includeEcoSystemData=true}
			}
			if (includeEcoSystemData) {
				var ecoSystemType=[];
				if (tcfdata.RelatedFromEcoSystemType && tcfdata.RelatedFromEcoSystemType.length > 0) {
					ecoSystemType=tcfdata.RelatedFromEcoSystemType
					var ecoSystemTypeStr='';
					ecoSystemType.forEach(function(type) {
						ecoSystemTypeStr=ecoSystemTypeStr + ",'" + type + "'";
					});
					ecoSystemTypeStr='(' + ecoSystemTypeStr.substring(1) + ')';
				}
				if (haveDebug) { Dump('\tecoSystemTypeStr',ecoSystemTypeStr); }
			}
		}
		if (haveDebug) { Dump('\tincludeEcoSystemData',includeEcoSystemData); Debug(''); }

	//Set options from tcfdata in config file
		var relatedVar=[];
		if (tcfdata.RelatedVar && tcfdata.RelatedVar.length > 0)
			relatedVar=tcfdata.RelatedVar
		if (haveDebug) { Dump('\trelatedVar',relatedVar.toSource()); }

	//Try block encapsulated main function
	try {
		// initial checks
			if (args && args.context && args.context != "wfrule")
				throw 'Failed rule type check';
			if (!tcfdata.code || !tcfdata.code.length)
				throw 'Failed code not null check';
			if (tcfdata.wfPathbase === "/courseadmin/") {
				if (!tcfdata.subject || !tcfdata.subject.length)
					throw 'Failed subject not null check';
			}
			if (!tcfdata.department || !tcfdata.department.length)
				throw 'Failed department not null check';
			if (!tcfdata.college || !tcfdata.college.length)
				throw 'Failed college not null check';

		// Get proposal data
			var parentCode=tcfdata.code[0];
			if (tcfdata.subject && tcfdata.subject.length > 0 ) {
				var parentSubj=tcfdata.subject[0].code;
			}
			var parentDept=tcfdata.department[0].code;
			var parentCol=tcfdata.college[0].code;
			if (haveDebug) { Dump('\tparentCode',parentCode); Dump('\tparentSubj',parentSubj); Dump('\tparentDept',parentDept); Dump('\tparentCol',parentCol); }

			// If request type is school then lookup school code
			if (reqType.indexOf('school') > 0) {
				hasSchool=true;
				// Lookup parent school
				var parentSchool='';
				sql='SELECT school FROM cimlookup WHERE department=? and college=?';
				sqlParms=[parentDept,parentCol];
				rows=dbquery(tcfdata.dbname[0],sql,sqlParms);
				if (rows.length >0 ) {
					parentSchool=rows[0].school;
				}
				if (haveDebug) { Dump('\tparentschool',parentSchool); }
			}

		//==================================================================================================
		// MAIN
		//==================================================================================================
		var ref={};
		// loop through form data variables, pull data and set refs array
			var refsArray=[];
			var refsLookup={};
			var formVar, formVarFormat;
			relatedVar.forEach(function(formVar) {
				var tmpArray=formVar.split('|');
				formVar=tmpArray[0];
				formVarFormat='c'; // default value
				formVarAttr='code'; // default value
				// Parse off formVar name and optional forVar format (i.e. formVarName|formVarFormat|formVarAttributeName)
				if (tmpArray.length > 1) {
					formVarFormat=tmpArray[1];
					var tempStr=formVarFormat.toLowerCase().substr(0,1);
					formVarFormat=tempStr
					formVarAttr=tmpArray[1];
				}
				if (tmpArray.length > 2) {
					formVarAttr=tmpArray[2];
				}
				if (haveDebug) { Debug("\n\tProcessing form variable: '" + formVar + "'"); }
				if (haveDebug) { Debug("\t\tformat: '" + formVarFormat + "'..."); Debug("\t\tattribute: '" + formVarAttr + "'"); }

				var tcfData=[];
				tcfData=eval('tcfdata.'+formVar); // jshint ignore:line
				if (typeof(tcfData) === 'undefined') {
					Debug('\t\t*** Variable ' + formVar + ' is not defined in the tcf file, skipping');
					return;
				}
				if (haveDebug) { Dump('\t\ttcfData',tcfData.toSource()); }
				var tcaData=[];
				if (typeof eval('tcadata.'+formVar) != 'undefined' )
					tcaData=eval('tcadata.'+formVar); // jshint ignore:line
				if (haveDebug) { Dump('\t\ttcaData',tcaData.toSource()); }

				// Make a has table of the related data
				tcfData.forEach(function(data) {
					ref={};
					var tempArray=eval('data.'+formVarAttr+'.split(" ")');
					//if (haveDebug) { Dump('\t\t tempArray',tempArray.toSource()); }
					if (formVarFormat === 'c') { // format=code, i.e. 'subj num' or 'subj-num'
						// Parse off the subject code from number
						tmpData=tempArray[0];

						if (tmpData.indexOf(" ",tmpData) >= 0) {
							tempArray=tmpData.split(" ");
						} else if (tmpData.indexOf("-",tmpData) >= 0) {
							tempArray=tmpData.split("-");
						}
						ref.data=tempArray[0];
						ref.format='subj';
					} else if (formVarFormat === 'd') { // format=dept
						ref.data=data.tempArray[0];
						ref.dept=data.tempArray[0]
						ref.format='dept';
					} else if (formVarFormat === 's') { // format=subj
						ref.data=data.tempArray[0];
						ref.format='subj';
					}
					if (ref != {}) {
						ref.source=formVar;
						if (haveDebug) { Dump('\t\tref',ref.toSource()); }
						refsArray.push(ref);
					}
					refsLookup[data.toSource()]=refsArray.length-1;
				}); //tcfData
				//if (haveDebug) { Dump('\t\trefsArray',refsArray.toSource());Dump('\t\trefsLookup',refsLookup.toSource()); }

				// Scan the tca data and see if there are any elements not in the tcf data, i.e. it has been deleted
				tcaData.forEach(function(b) {
					if (refsLookup[b.toSource()] === undefined) {
						if (haveDebug) {Debug("\t\tAdding deleted code to refsArray: " + b.toSource());}
						refsArray.push(b);
					}
				}); //tcfData

				// Check to see if the subject code has change, if yes then include the origional subject code in the refsArray
					if (tcadata.subject && tcadata.subject.length > 0) {
						if (tcadata.subject[0].code != parentSubj) {
							if (haveDebug) { Debug('\tSubject code changed, adding origional (from tca): ' + tcadata.subject[0].code);}
							refsArray.push({code:tcadata.subject[0].code});
						}
					}
				// Check to see if the department code has change, if yes then include the origional subject code in the refsArray
					if (tcadata.department && tcadata.department.length > 0) {
						if (tcadata.department[0].code != parentDept) {
							if (haveDebug) { Debug('\tDepartment code changed, adding origional (from tca): ' + tcadata.department[0].code);}
							refsArray.push({department:tcadata.department[0].code});
						}
					}
				//if (haveDebug) { Dump('\t\trefsArray',refsArray.toSource()); }
			}); //relatedVar

		var sqlStmt, sqlParms, resultSet=[];
		//Check for any cross references data for this course in the crossref table (eco system)
			if (includeEcoSystemData) {
				if (haveDebug) { Debug("\n\tRetrieving data from the eco system...");}
				// Get referenced dept data from courseref, parse path to find out type of reference and add to refsArray
					sqlStmt="SELECT DISTINCT path,dept FROM courseref WHERE code = ? AND dept <> ? AND dept <> ''";
					if (typeof(ecoSystemTypeStr) != 'undefined'  )
						sqlStmt=sqlStmt + ' AND type IN ' + ecoSystemTypeStr
					sqlParms=[parentCode,parentDept];
					resultSet=dbquery("courseref", sqlStmt,sqlParms);
					if (haveDebug) { Debug('\t\tCourseref query returned ' + resultSet.length + ' records.'); }
					resultSet.forEach(function(result) {
						//if (haveDebug) { Dump('\nresult',result.toSource()); }
						ref={};
						if (result.path.substr(0,1) === '/' || result.path.substr(0,12) === 'programcode:') { // i.e. a catalog or programadmin ref
							if (result.dept != parentDept) {
								ref.data=result.dept;
								ref.dept=result.dept;
								ref.format='dept';
							}
						} else { // i.e. a course ref
							ref.data=result.dept;
							ref.format='subj';
						}
						if (typeof ref.data != 'undefined') {
							ref.source='eco:'+ result.path.substr(0,1);
							refsArray.push(ref);
							if (haveDebug) { Debug("\t\t\t" + ref.toSource());}
						}
					}); //resultSet
			} //includeEcoSystemData

			if (refsArray.length === 0) {
				if (haveDebug) { Debug("\t*** Zero (0) items to add");}
				return false;
			}

		// Look up the output tokens based on how we were called (Dept, Col, School)
			//if (haveDebug) { Debug("\n\tRetrieving data from the eco system...");}
			var outTokens=[], steps=[]
			refsArray.forEach(function(ref) {
				//if (haveDebug) { Dump('\t\tref',ref.toSource()); }
				sqlStmt='';
				if (reqType.indexOf('depts') > 0) {
					searchStr='Dept';
					if (tcfdata.RelatedDeptsSteps && tcfdata.RelatedDeptsSteps.length > 0)
						steps=tcfdata.RelatedDeptsSteps;
					if (ref.format === 'dept' ) {
						outTokens.push(ref.dept);
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct department as token FROM cimlookup WHERE subject=? and department <> ?";
						sqlParms=[ref.data,parentDept];
					}

				} else if (reqType.indexOf('colleges') > 0) {
					searchStr='Col'
					if (tcfdata.RelatedCollegesSteps && tcfdata.RelatedCollegesSteps.length > 0)
						steps=tcfdata.RelatedCollegesSteps;
					if (ref.format === 'dept' ) {
						sqlStmt="SELECT distinct college as token FROM cimlookup WHERE department=?";
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct college as token FROM cimlookup WHERE subject=?";
					}
					sqlParms=[ref.data];
				} else if (reqType.indexOf('schools') > 0) {
					searchStr='School'
					if (tcfdata.RelatedSchoolsSteps && tcfdata.RelatedSchoolsSteps.length > 0)
						steps=tcfdata.RelatedSchoolsSteps;
					if (ref.format === 'dept' ) {
						sqlStmt="SELECT distinct school as token FROM cimlookup WHERE department=?";
					} else if (ref.format === 'subj' ) {
						sqlStmt="SELECT distinct school as token FROM cimlookup WHERE subject=?";
					}
					sqlParms=[ref.data];
				}
				if (sqlStmt != '') {
					resultSet=dbquery("cimcourses",sqlStmt,sqlParms);
					resultSet.forEach(function(result) {
						//if (haveDebug) { Dump('\t\t\ttoken',result.token); }
						outTokens.push(result.token);
					});
				}
			}); //refsArray

			outTokens=RemoveDupes(outTokens);
			if (haveDebug) {
				Debug('\n\tOutput tokens (' + searchStr + '):');for (var key in outTokens) { Dump('\t\toutTokens[' + key + ']',outTokens[key].toSource()); }('');
				if (steps.length > 0)
					Debug('\n\tSteps defined in config file:');for (var key in steps) { Dump('\t\tsteps[' + key + ']',steps[key].toSource()); }(''); 
			}

		// Output the steps
			var retArray=[];
			if (haveDebug) { Debug("\n\tReturn step data for " + outTokens.length + " " + searchStr + "(s)...");}
			if (EnvIs('dev'))
				if (typeof tcfdata.debugDev != "undefined")
					if (tcfdata.debugDev === 'true')
						retArray.push('*** START of ' + inval.toLowerCase().replace('optional','') + ' ***');


			outTokens.forEach(function(token) {
				if (token === '') return;
				if (inval == wfrule.searchfor) {
					//if ((steps.length === 0) && (haveDebug)) { Debug("\t*Error* -- Zero steps defined"); }
					if (steps.length === 0 && haveDebug) { Debug("\t*Error* -- Zero steps defined"); }
					steps.forEach(function(step) {
						step=step.replace(searchStr,token);
						if(notifyMode) {
							if (step.indexOf(' fyi') < 0) {
								step=step + ' fyiall';
							} else if (step.indexOf(' fyi') >= 0) {
								step=step.replace(' fyi',' fyiall');
							}
						}
						retArray.push(step.trim());
						Dump('\t\tReturning step: ',retArray[retArray.length-1]);
					});	//steps
				} else {
					retArray.push(inval.replace(wfrule.regex,token).trim());
					Dump('\t\tStep: ',retArray[retArray.length-1]);
				}
			}); //outTokens
			if (EnvIs('dev'))
				if (typeof tcfdata.debugDev != "undefined")
					if (tcfdata.debugDev === 'true') 
						retArray.push('*** END of ' + inval.toLowerCase().replace('optional','') + ' ***');

		return retArray;
	} //try

	//Catch block for errors thrown in above try block
	catch(err) { if (haveDebug) { Debug(err); } else { throw myName + ': ' + err; } return false; }

	// Should never get here
	return false;
}; //Related

//Set include SIS step on (true) or off (false) -- only applys to DEV env.
//addSisEnvs:test,next
//wfrules:SISsync|function|AddSisStep|
//=========================================================================================================================
// Pull the sisName value in the config file and replace that in the workflow, include in workflow if
// not running.  Only add sissync step if current env is in 'tcfdata.addSisEnvs'
// ??/??/2014 - dgs - New
// 02/26/2015 - dgs - Refactored to move sisname = '' warning earlier, add sisname to other messages
// 01/25/2016 - dgs - Refactored check env in addSisEnvs
//=========================================================================================================================
wffuncs.AddSisStep = function(inval, wfrule, args) {
	// setup
	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug) { Debug('\n*** In '+ myName + ' ***'); /* Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); */ }
	// Check execution env
	if(args && args.context && args.context != "wfrule")
		return false;

	// Get sisname from cimconfig.cfg
	if (tcfdata.sisname === '') {
		var spaceing='&nbsp;&nbsp;&nbsp;&nbsp;';
		print_doc(spaceing + '<strong>*Error* -- (' + myName + ') Default SIS name not set in cimconfig.cfg file.<br>' + spaceing + 'Please contact your CourseLeaf Administrator.</strong>');
		Debug('\t *Error* -- Default SIS name not set in cimconfig.cfg file.');
		return false;
	}

	if (typeof tcfdata.addSisEnvs == "undefined") {
		Debug("\t*Warning* -- tcfdata.addSisEnvs undefined, adding sis sync step");
		return tcfdata.sisname.toString().trim();
	}

	if (tcfdata.addSisEnvs[0].indexOf(GetEnv().toString()) < 0){
		print_doc("&nbsp;&nbsp;&nbsp;<strong><em>*Warning*</strong> -- (" + myName + ") Not including SIS Sync step (" + tcfdata.sisname + ")");
		print_doc("<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp" + 
			"env = " + GetEnv().toString() + " and addSisEnvs = '" + tcfdata.addSisEnvs + "'" );
		return false; 
	}

	// Add SIS Sync Step
	Debug('\tAdding SIS Sync step: ' + tcfdata.sisname.toString().trim());
	return tcfdata.sisname.toString().trim();

}; //AddSisStep

//==================================================================================================
// Check the proposal mode
// 09/10/2015 - dgs - New
//==================================================================================================
wffuncs.CheckProposalMode = function(inval, wfrule, args) {
	var myName=wfrule.attrname; wfDebug('\n*** In '+ myName + " called as '" + wfrule.searchfor + "' ***");
	var reqType=wfrule.searchfor.toUpperCase();
 	var propMode = GetProposalMode();
	//wfDump(['reqType;'+reqType,'propMode;'+propMode])

	if (reqType.indexOf(propMode) >= 0) {
		wfDebug("\t*** Including step")
		return [inval.replace(wfrule.ifregex,'')];
	}

	return false;

}; //CheckProposalMode

//==================================================================================================
//==================================================================================================
// Common utilities
//==================================================================================================
//==================================================================================================

//==================================================================================================
// Return data from the eco system for this course
// returns an array of reference objects, each reference object is of the form:
// {ref:data ref:dept ref:format}
// format is in {'subj','dept','path'}
//==================================================================================================
// 07/13/16 -- dgs -- Initial
// 07/27/16 -- dgs -- Remove duplicates before returning data
//==================================================================================================
function GetEcoSystemData(parentCode,parentDept,ecoSystemTypeStr) {
	if (parentCode == "" || parentDept == "") return false;
	var tmpArray=parentCode.split(' ');
	var parentSubj=tmpArray[0];
	//wfDump(['parentCode;'+parentCode,'parentDept;'+parentDept,'parentSubj;'+parentSubj]);

	var refsArray=[];
	//Check for any cross references data for this course in the crossref table (eco system)
		var sqlStmt="SELECT DISTINCT path,dept,type FROM courseref WHERE code = ? AND dept <> ? AND dept <> ''";
		if (typeof(ecoSystemTypeStr) != 'undefined'  ) {
			if (ecoSystemTypeStr != "") sqlStmt=sqlStmt + ' AND type IN ' + ecoSystemTypeStr
		}

		var sqlParms=[parentCode,parentDept];
		//wfDump(['sqlStmt;'+sqlStmt,'sqlParms;'+sqlParms.toSource()]);
		var resultSet=dbquery("courseref",sqlStmt,sqlParms);
		var checkArray=[];
		resultSet.forEach(function(result) {
			var ref={};
			if (result.path.substr(0,1) === '/') {
				if (result.dept != parentDept) {
					ref.source='eco-cat';
					ref.data=result.dept;
					ref.format='dept';
					ref.type=result.type;
				}
			} else if (result.path.substr(0,12) === 'programcode:') {
				if (result.dept != parentDept) {
					ref.source='eco-program';
					ref.data=result.dept;
					ref.format='dept';
					ref.type=result.type;
				}
			} else if (result.path.substr(0,5) === 'code:') {
				if (result.dept != parentSubj) {
					ref.source='eco-course';
					ref.data=result.dept;
					ref.format='subj';
					ref.type=result.type;
				}
			}
			var key=ref.source+ref.data+ref.format+ref.type
			if (Object.keys(ref).length != 0 && typeof checkArray[key] === 'undefined') {
				refsArray.push(ref); checkArray[key]=true;
			}
		}); //resultSet

		wfDebug("\tFound " + refsArray.length.toString() + " distinct references found from the Eco System:")
		refsArray.forEach(function(ref) { wfDump(['\tref;'+ref.toSource()]); });

	return refsArray;
}

//==================================================================================================
// Initial Checks
// Input is an array of variable names and the the std wffuncs 'args' variable.
// Will check to make sure each element of the array is not undefined and has a non-null value
// If the variable name is 'wforder' or 'wfrule' then it will check agains the 'args' data to make 
// verify the call type.
// e.g. InitialChecks['wforder','code','department'];
//==================================================================================================
InitialChecks = function(checkVars,args) {
	var tcfData={};

	for (var i=0,  tot=checkVars.length; i < tot; i++) {
		var checkVar=checkVars[i];
		//Dump('\tcheckVars[' + i + ']',checkVar);
		if (checkVar === 'wfrule' || checkVar === 'wforder') {
			if (args && args.context && args.context != checkVar)
		 		throw "*** Failed rule type='" + checkVar + "'' check";
		} else {
			tcfData=eval('tcfdata.'+checkVar); // jshint ignore:line
			//Dump('\t\ttcfData',tcfData);
			if (typeof tcfData === "undefined")
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is undefined";
			if (tcfData == null)
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is not null check(1)";
			if (tcfData == "")
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is not null check(2)";
		}
	} //for loop
	return;
} //InitialChecks

//==================================================================================================
// Return the proposal mode
// 02/26/2015 - dgs - New
//==================================================================================================
GetProposalMode = function() {
	var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	var retVal='EDIT';
	if (tcfdata.newrecord && tcfdata.newrecord.length) {
		if (tcfdata.newrecord == 'true')
			retVal='NEW';
	}
	if (tcfdata.deleterec && tcfdata.deleterec.length) {
		if (tcfdata.deleterec == 'true')
			retVal='DELETE';
	}

	if (haveDebug) { Debug('\t*** Proposal mode: ' + retVal); }
	return retVal;

}; //GetProposalMode

//==================================================================================================
// Helper function to check changed fields against a list of fields to see if:
// 	mode=only 	- Check that ALL of the changed fields are in the list e.g.
// 		if (CheckChange(diffdata,ignoreChangeFields,'only')) {}
// 	mode=any	- Check to see that ANY of the change fields are in the list  e.g.
// 		if (CheckChange(diffdata,ignoreChangeFields,'any')) {}
//
// returns true if only allowed fields have changed or no fields have changed, otherwise returns false;
//
// gets diffdata passed in as parm
// Get a list of fields that have changed
// var diffdata = {};
// tcfview.compare(tcfdata.key[0], {addwarnings: false, retdata: diffdata});
//
// 02/16/15	-- dgs -- New
// 10/12/15 -- dgs -- simplified logic
// 04/19/16 -- dgs -- Fix logic for 'ONLY'
//===================================================================================================
function CheckChanged(diffdata,checkFields,mode,quiet) {
	var myName='CheckChanged';
	var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug && ! quiet) Debug('\n*** In ' + myName + ' ***');

	 //Try block encapsulated main function
	 try {
			if (arguments.length < 2)
	 		throw "\t*** Insufficinent arguments passed in";

			mode=mode.toLowerCase();
			if (haveDebug && ! quiet) { checkFields.forEach(function(checkField) { Dump('\tcheckFields',checkField); }); print_debug('\n'); }

			if (!Object.keys(diffdata).length)
				throw "\tNo fields have changed";
			var foundAnyAllowed=false;
			var foundOnlyAllowed=true;
			//Loop through changed fields and see if any field other than the allowed fields has changed
			for (var changedField in diffdata) {
				var foundInCheckfields=false;
				checkFields.forEach(function(checkField) {
					if (checkField.toString() == changedField) foundInCheckfields=true;
				});  // jshint ignore:line

				if (haveDebug && ! quiet) { Debug("\tChanged Field: " + changedField + ", foundInCheckfields: " + foundInCheckfields); }
				if (foundInCheckfields === false ) { foundOnlyAllowed=false; } else { foundAnyAllowed=true; }
			} // i in diffdata

			if (haveDebug && ! quiet) { print_debug("\n"); Debug('\tfoundOnlyAllowed: ' + foundOnlyAllowed); }
			if (haveDebug && ! quiet) { Debug('\tfoundAnyAllowed: ' + foundAnyAllowed); }
			if (foundOnlyAllowed === true && mode == 'only') return true;
			if (foundAnyAllowed === true && mode == 'any') return true;
			return false

		} //Try block

	//Catch block for errors thrown in above try block
	catch(err) { if (haveDebug && ! quiet) { Debug(err); } else { throw myName + ': ' + err; } return false; }	// Should never get here
	return false;
} //CheckChanged

//==================================================================================================
// Check execution environment, passed one argument 'env' that can hav values 'dev' or 'test'
// compares execution url (host) against arg and if there is a match then returns true, otherwise
// returns false
//==================================================================================================
EnvIs = function(env) {
	var host=getenv("HTTP_HOST").toUpperCase() ;
	if (env.toUpperCase() == 'DEV' && host.indexOf('.DEV') > 0)
			return true;
	if (env.toUpperCase() == 'TEST' && host.indexOf('-TEST.') > 0)
			return true;
	if (env.toUpperCase() == 'NEXT' && host.indexOf('-NEXT.') > 0)
			return true;
	return false;
}; //EnvIs
GetEnv = function(env) {
	var host=getenv("HTTP_HOST").toLowerCase() ;
	if (host.indexOf('.dev') > 0) {
			return 'dev';
	} else if (host.indexOf('-test') > 0) {
			return 'test';
	} else if (host.indexOf('-next') > 0) {
			return 'next';
	}
	return '*unknown*';
} //EnvIs

//==================================================================================================
// Helper function to print a formatted debug message or dump a variable
// Syntax: 	Debug(string [,mode])
//			Dump(varName,varValue [,mode,callerName])
//			mode in {'D','S','B'}  D=print_debug, S=print_doc, B=both
//			if mode is numeric then it is the message Level
//
//==================================================================================================
// 08/22/2014 -- dgs -- New
// 10/31/2014 -- dgs -- tweaked the 'Under Construction' stuff
// 12/10/2014 -- dgs -- Cleand up things a bit
// 12/17/2014 -- dgs -- Removed meglevel,
// 02/10/2015 -- dgs -- Added message level back.
//==================================================================================================
function Debug(text,mode,level){
	var myName=arguments.callee.toString(); myName=myName.substr('function '.length); myName=myName.substr(0, myName.indexOf('('));

	// Check to see if we should continue
		if (typeof tcfdata.debugEnvs == "undefined") return
		var debugEnvs=','+tcfdata.debugEnvs+','
		if (debugEnvs.indexOf(','+GetEnv()+',') < 0) return

	// Set variables if this is not a full call
		if (arguments.length < 1) {
			print_debug('* Error * -- Invalid call to "' + myName +'", insufficinent arguments passed' );
			return;
		}

	// Set level and mode if necessary
		if (mode === undefined) mode='D';
		if (typeof mode == 'number') { mode='D'; level=mode; }
		if (level === undefined) level=0;

	// Check against debugLevel
		if (tcfdata.debugLevel != undefined) {
			if (tcfdata.debugLevel < level) return;
		}

	// Print message
		mode=mode.toUpperCase();
		if ( mode == 'D' || mode == 'B' )
			print_debug(text + ' \n');
		if ( mode == 'S' || mode == 'B' )
			print_doc("&nbsp;&nbsp;&nbsp;" + text + ' <br>');
	return;
} //Debug

function Dump(varName,varValue,mode,callerName){
	var myName=arguments.callee.toString(); myName=myName.substr('function '.length); myName=myName.substr(0, myName.indexOf('('));
	// Set variables if this is not a full call
	if (arguments.length < 2) {
		print_debug('* Error * -- Invalid call to "' + myName +'", insufficinent arguments passed' );
		return;
	}
	text=varName + ' = >' + varValue + '<';
	Debug(text,mode,callerName);
} //Dump

function Here(id) {
	print_debug('Here ' + id + '\n');
} //Here

//==================================================================================================
// Print a formatted debug message if current ennvironment is on the tcfdata.debugEnvs list.
// Passed two arguments:
// string 	-- The text to print
// mode 	-- The mode ('S' for screen, 'D' for wizdebug), default is 'D'
//==================================================================================================
// 07/22/16 -- dgs -- Initial
//==================================================================================================
function wfDebug(text,mode){
	// Check to see if we should continue
		if (typeof tcfdata.debugEnvs == "undefined") return
		var debugEnvs=','+tcfdata.debugEnvs+','
		if (debugEnvs.indexOf(','+GetEnv()+',') < 0) return
	// set Mode
		if (typeof mode === 'undefined') mode="D"
		mode=mode.toUpperCase();
	// Print message
		if ( mode == 'D' || mode == 'B' )
			print_debug(text + ' \n');
		if ( mode == 'S' || mode == 'B' )
			print_doc("&nbsp;&nbsp;&nbsp;" + text + ' <br>');
	return;
} //Debug

//=================================================================================================
// Formatted print an list of variables, is passed 2 arguments:
// [array]		-- each element is of the form 'variableName<delimiter>variableValue'
// 'delimiter'	-- the delimiter char to seperate name from value, default is ';'
//=================================================================================================
// 07/22/16 -- dgs -- Initial
//==================================================================================================
function wfDump(varList,delimiter){
	// Set variables if this is not a full call
	if (typeof varList != 'object') { print_debug("*Error* -- wfDump: invalid argument type\n"); return;}
	if (typeof delimiter === 'undefined') delimiter=";"
    varList.forEach(function(v) {
    	var tokenArray=v.split(delimiter);
		wfDebug("\t"+ tokenArray[0] + ' = >' + tokenArray[1] + '<');
    });;
} //wfDump

//==============================================================================================
// Helper function to check to see if a variable has a value, if not then print a message and return false
// e.g. if (! CheckForVal(tcfdata.rotation,'Course Rotation',ChangeTypeFirstRun)) { ChangeTypeFirstRun=false; return false; }
//==============================================================================================
function CheckForVal(varName,varValue) {
	//print_debug('\tvarName = ' + varName + ', varValue =' + varValue + ',varValue.length  = ' + varValue.length + '\n');
	if (!varValue || !varValue.length) {
		print_doc('&nbsp;&nbsp;<strong>*WARNING*</strong> -- Data Field&nbsp;&nbsp;<em>\'' + varName + '\'</em>&nbsp;&nbsp;does not have a value, workflow calculation incomplete.<br>');
		return false;
	}
	return true;
} //CheckForVal

//==================================================================================================
// Helper function to remove duplicates from an array
//==================================================================================================
function RemoveDupes(arr,exclude) {
    var noDupes=[];
    exclude=' ' + exclude + ' ';
    arr=arr.sort();
    arr.forEach(function(value) {
		//if (typeof(Dump) == "function") { var num=noDupes.indexOf(value); Dump('\t\tIn Remove Dupes, index of ' + value + ' in input array',num); }
        if ( noDupes.indexOf(value) == -1 && exclude.indexOf(' '+value+' ') < 0 ) {
            noDupes.push(value);
        }
    });
    return noDupes;
} //RemoveDupes

//==================================================================================================
// Helper function to output the list of fields that have changed
// runs as a wforder directive
// 12/17/2014 -- dgs -- Updated for new Debug / Dump syntax
// 01/12/2015 -- dgs -- Tewaked the output format to the screen
// 02/10/2015 -- dgs -- Exit if not running in dev
//==================================================================================================
if(typeof WhatsChangedFirstRun == "undefined") var WhatsChangedFirstRun = true;
wffuncs.WhatsChanged = function(inval, wfrule, args) {
	if (!WhatsChangedFirstRun) return false;
	var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (!haveDebug) return false;
	if (!WhatsChangedFirstRun) return false;
	var myName=wfrule.attrname;
	Debug('\n*** In ' + myName + ' ***');

	//Get a list of fields that have changed
	var diffdata = {};
	tcfview.compare(tcfdata.key[0], {addwarnings: false, retdata: diffdata});

	if (!Object.keys(diffdata).length) {
		Debug('\tNo Changes found in form data','b');
	} else {
		Debug('\t<strong><em>Changed Fields:</em></strong>','s');
		Debug('\tChanged Fields:','d');
		for (var i in diffdata) {
			Debug('\t\t' + i.toString() + ' (' + eval('tcfdata.' + i + '.toSource()') + ')','d');  // jshint ignore:line
			Debug('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp' + i.toString(),'s');
		}
	}

	WhatsChangedFirstRun = false;
	return false;
}; //wffuncs.WhatsChanged
