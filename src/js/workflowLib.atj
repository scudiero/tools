//======================================================================================================================
wfLibVersion="1.7.2" // -- dscudiero -- 03/10/2017 @ 15:21:41.61
//======================================================================================================================
// Common wf functions and helper functions to support workflow
//======================================================================================================================
if (typeof wfLibLoaded === "undefined") {
	if (typeof wfInDebugEnv != "undefined") {
		if (wfEnvIsDev) print_debug("\n<<< Loading "+ wfLibName);
	} else { wfInDebugEnv = true }
}

//======================================================================================================================
//======================================================================================================================
// Common wffuncs
//======================================================================================================================
//======================================================================================================================

//======================================================================================================================
// Add related departments/colleges/schools to the workflow,
// returned data is sorted by code and duplicates are removed.
//======================================================================================================================
//
// Global switches/flags/data:
//		_checkChanged 		Check to see if the proposal values for the substitution type have
//							changed and if change detected then add original values to the output
//							default: true
//
//		_ecoSystemData 		Included data from the Eco system in the results
//
//		_ecoSystemType 		If retrieving data from the eco system you may define which references types to use
//							This is used to match against the type field in the echo system record, if not specified
//							all reference types are considered valid.
//							e.g. 	Related_ecoSystemType:equiv
//
//		_ecoSystemDataFyi	If retrieving data from the eco system, should the steps be added as fyi steps.
//							The value must be in the set {"fyi","fyiall"} and the token is tacked on to the
//							end of the generated steps.
//							e.g. 	Related_ecoSystemTypeFyi:equiv
//
//		_formFieldVars		The form fields that contain 'related/crosslisted/associated/consultant' data.
//							The formate is name[|format][|dataAttributeName] where :
//							format is one item in the set {courseCode,colCode,deptCode,subjCode}, the default is 'code'
//							dataAttributeName is the hame of the object attribute that contains the data for the reference, default is 'data'
//							May be repeated as necessary.
//							e.g. 	Related_formFieldVars:crosslisted|code; 	//Applies to all Related wfrule
//									Related_formFieldVars:slashlisted|code; 	//Applies to all Related wfrule
//
//		_codeVarName		The name of the form variable containing the 'code' data, defaults to 'code'
//		_colVarName			The name of the form variable containing the 'college' data, defaults to 'college'
//		_deptVarName		The name of the form variable containing the 'department' data, defaults to 'department'
//		_subjVarName		The name of the form variable containing the 'subject' data, defaults to 'subject'
//
//=================================================================================================
// Notes:
//	1) 	Variables above can be specific to a wfrule or general across all 'Related' wfrules in the
//		config file.  If you want specific values for each wfrule defined then precede the variable
//		with the name of the rule.  I.e. if the wfrule name is 'RelatedAndCrosslistedDepts' then name
//		the variable as 'RelatedAndCrosslistedDepts_<fieldName>',  E.g. 'RelatedAndCrosslistedDepts_formFieldVars'
//		If you want the variable to apply to ALL defined rules the prefix the variable with the name
//		of this function,  i.e.  'Related_<fieldName>',  E.g. 'Related_formFieldVars'//
//
//	2) The substitution type ("department","college","subject","school") is determined as follows
//		1) 	It may be passed in on the rule definition.
//			E.g. 'wfrules:RelatedCrosslistedSlashlistedDepts|function|Related|<substitutionType>;'
//		2) 	If not passed in on the wfrule definition then the wfrule name is scanned for the
//			the following strings and the substitution type is set as indicated:
//			'dep'	= department
//			'col'	= college
//			'sub'	= subject
//			'sch'	= school
//
//======================================================================================================================
// Examples
//======================================================================================================================
// wfrules:RelatedCrosslistedSlashlistedDepts|function|Related|;
// RelatedCrosslistedSlashlistedDepts_ecoSystemData:true
// RelatedCrosslistedSlashlistedDepts_ecoSystemDataFyi:false
// RelatedCrosslistedSlashlistedDepts_formFieldVars:crosslisted|courseCode|code
// RelatedCrosslistedSlashlistedDepts_formFieldVars:slashlisted|courseCode|code
//
// wfrules:RelatedCrosslistedSlashlistedCols|function|Related|;
// RelatedCrosslistedSlashlistedCols_ecoSystemData:true
// RelatedCrosslistedSlashlistedCols_ecoSystemDataFyi:false
// RelatedCrosslistedSlashlistedCols_formFieldVars:crosslisted|courseCode|code
// RelatedCrosslistedSlashlistedCols_formFieldVars:slashlisted|courseCode|code
//
// - OR  - (yields the same results)
//
// Related_ecoSystemData:true
// Related_ecoSystemDataFyi:fyi
// Related_formFieldVars:crosslisted|courseCode|code
// Related_formFieldVars:slashlisted|courseCode|code
// wfrules:RelatedCrosslistedSlashlistedDepts|function|Related|;
//======================================================================================================================
// 11/15/16	- dgs - Re-factored to allow for the specification of the core proposal variable names
//======================================================================================================================
wffuncs.Related = function(inval, wfrule, args) {
	var version='4.9.5'; var myName=wfrule.attrname
	wfDebug(3,'\n*** In '+ myName + " (" + version + ") called as '" + args.context + " / " + wfrule.searchfor + "' ***");
	wfDump(3,["Full Step text;"+inval]);

	//==================================================================================================================
	// Setup
	//==================================================================================================================

	// Determine mode (dept / college) based on the mapped name
		var notifyMode=false;
		var hasSchool=false;
		var calledAs=wfrule.searchfor;
		var reqType=calledAs.toLowerCase();
		if (reqType.substr(reqType.length - 'notify'.length) == 'notify') {
			notifyMode=true;
		}
		var substitutionType;
		var callOpts=wfrule.options.toLowerCase()
		var tmpArray=callOpts.split(";");
		callOpts=tmpArray[0];
		if (callOpts.length === 0) {
			if (reqType.indexOf("dep") >= 0) { substitutionType="dept";
			} else if (reqType.indexOf("col") >= 0) { substitutionType="college";
			} else if (reqType.indexOf("subj") >= 0) { substitutionType="subject";
			} else if (reqType.indexOf("school") >= 0) { substitutionType="school";
			} else { substitutionType="dept"
			}
		} else {
			substitutionType=callOpts.toString()
		}

	wfDump(3,["calledAs;"+calledAs,"reqType;"+reqType,"notifyMode;"+notifyMode,"callOpts;"+callOpts,"substitutionType;"+substitutionType]);

	//Get the data from the config file
		// Control data
			var checkChanged;
				varName="tcfdata." + calledAs + "_" + "_checkChanged";
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_checkChanged"; }
				if (typeof eval(varName) != 'undefined') { checkChanged=eval(varName)[0]; }
				if (checkChanged === "true") {checkChanged=true} else {checkChanged=false}

			var ecoSystemData;
				varName="tcfdata." + calledAs + "_" + "ecoSystemData";
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_ecoSystemData"; }
				if (typeof eval(varName) != 'undefined') { ecoSystemData=eval(varName)[0]; }
				if (ecoSystemData === "true") {ecoSystemData=true} else {ecoSystemData=false}

			var ecoSystemType="";
				varName="tcfdata." + calledAs + "_" + "ecoSystemType";
				// If we have ecoSystemType data then reformat the string to be an valid sql 'in' string
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_ecoSystemType"; }
				if (typeof eval(varName) != 'undefined') {
					ecoSystemType=eval(varName)[0];
					var ecoSystemTypeStr='';
					var tempArray = ecoSystemTypeStr.split(",");
					tempArray.forEach(function(type) {
						ecoSystemTypeStr=ecoSystemTypeStr + ",'" + type + "'";
					});
					ecoSystemTypeStr='(' + ecoSystemTypeStr.substring(1) + ')';
				}

			var ecoSystemDataFyi="";
				varName="tcfdata." + calledAs + "_" + "ecoSystemDataFyi"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_ecoSystemDataFyi" }
				if (typeof eval(varName) != 'undefined') { ecoSystemDataFyi=eval(varName)[0]; }

		// Get the name of the proposal form variables
			var codeVarName="code";
				varName="tcfdata." + calledAs + "_" + "codeVarName"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_codeVarName" }
				if (typeof eval(varName) != 'undefined') { codeVarName=eval(varName)[0]; }

			var colVarName="college";
				varName="tcfdata." + calledAs + "_" + "colVarName"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_colVarName" }
				if (typeof eval(varName) != 'undefined') { colVarName=eval(varName)[0]; }

			var deptVarName="department";
				varName="tcfdata." + calledAs + "_" + "deptVarName"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_deptVarName" }
				if (typeof eval(varName) != 'undefined') { deptVarName=eval(varName)[0]; }

			var subjVarName="subject";
				varName="tcfdata." + calledAs + "_" + "subjVarName"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_subjVarName" }
				if (typeof eval(varName) != 'undefined') { subjVarName=eval(varName); }

			var formFieldVars=[];
			var formFieldVarsStr="";
				varName="tcfdata." + calledAs + "_" + "formFieldVars"
				if (typeof eval(varName) === 'undefined') { varName="tcfdata." + myName + "_formFieldVars" }
				if (typeof eval(varName) != 'undefined') {
					formFieldVarsStr=eval(varName).toString();
					formFieldVars=formFieldVarsStr.split(",");
				}

		wfDump(3,["\n\tcheckChanged;"+checkChanged.toSource(),"ecoSystemData;"+ecoSystemData.toSource(),"ecoSystemType;"+ecoSystemType,
			"ecoSystemDataFyi;"+ecoSystemDataFyi.toSource(),"formFieldVars;"+formFieldVars.toSource()])

	// Set internal variables for the proposal data, check we have what we need
		var proposalCode=null, proposalSubj=null, proposalDept=null, proposalCol=null;
		try {
			// initial checks
				if (args && args.context && args.context != "wfrule")
					throw "Failed 'rule type' check";

				if (wfCimInstance === "courseadmin") {
					if (eval("typeof tcfdata." + codeVarName) === 'undefined') {
						throw "Failed '" + codeVarName + "' not null check"
					} else { proposalCode=eval("tcfdata." + codeVarName + "[0]")}

					if (eval("typeof tcfdata." + subjVarName) === 'undefined') {
						throw "Failed '" + subjVarName + "' not null check"
					} else { proposalSubj=eval("tcfdata." + subjVarName + "[0].code")}
				}

				if (eval("typeof tcfdata." + colVarName) === 'undefined') {
					throw "Failed '" + colVarName + "' not null check"
				} else { proposalCol=eval("tcfdata." + colVarName + "[0].code")}

				if (eval("typeof tcfdata." + deptVarName) === 'undefined') {
					throw "Failed '" + deptVarName + "' not null check"
				} else { proposalDept=eval("tcfdata." + deptVarName + "[0].code")}
		} //try
		//Catch block for errors thrown in above try block
		catch(err) { wfDebug("\t*Error* -- " + myName + ": " + err + "\n"); return false; }
		wfDump(3,["\n\tproposalCode;"+proposalCode,"proposalSubj;"+proposalSubj,"proposalDept;"+proposalDept,,"proposalCol;"+proposalCol])

		if (proposalCode === undefined || proposalDept === undefined) {
			wfDebug(3,"\tproposalCode (" + proposalCode + ") or proposalDept (" + proposalDept + ") is undefined, skipping Eco System data")
			ecoSystemData=false;
		}

	//==================================================================================================================
	// Helper functions
	//==================================================================================================================
	// Build a ref object based on the passed in format code
	//==================================================================================================================
	ParseRelatedData = function(dataObj,format,dataAttributeName) {
		var ref={};
		format=format.toLowerCase();
		var data=eval("dataObj." + dataAttributeName);
		var tempArray=data.split(' ');

		ref.data=tempArray[0];
		ref.format="subj";

		if (format.indexOf("dep") >= 0) {
			ref.format="dept";
		} else if (format.indexOf("col") >= 0) {
			ref.format="col";
		}

		return ref;
	} //ParseRelatedData

	//==================================================================================================================
	// MAIN
	//==================================================================================================================
	var ref={};
	// If checkchanged flag is on then check if the proposal values have changed
		if (checkChanged) {
 			switch (substitutionType) {
 				case "dept":
	 				if (tcadata.department && tcadata.department.length > 0) {
						if (tcadata.department[0].code != proposalDept) {
							wfDebug(3,'\tDepartment code changed, adding original (from tca): ' + tcadata.department[0].code);
							refsArray.push({department:tcadata.department[0].code});
						}
					}
 					break;
  				case "college":
 	 				if (tcadata.college && tcadata.college.length > 0) {
						if (tcadata.college[0].code != proposalCol) {
							wfDebug(3,'\tDepartment code changed, adding original (from tca): ' + tcadata.college[0].code);
							refsArray.push({college:tcadata.college[0].code});
						}
					}
 					break;
  				case "subj":
 	 				if (tcadata.subject && tcadata.subject.length > 0) {
						if (tcadata.subject[0].code != proposalSubj) {
							wfDebug(3,'\tDepartment code changed, adding original (from tca): ' + tcadata.subject[0].code);
							refsArray.push({code:tcadata.subject[0].code});
						}
					}
 			}//switch
		} //checkChanged

	// loop through form data variables, pull data and set refs array
		var refsArray=[];
		var refsLookup={};
		var formVar, formVarFormat, dataAttributeName;
		formFieldVars.forEach(function(formVar) {
			var tmpArray=formVar.split('|');
			formVar=tmpArray[0];
			formVarFormat='courseCode'
			// Parse off formVar name and optional forVar format (i.e. formVarName|formVarFormat|dataAttributeName)
			if (tmpArray.length > 1) {
				formVarFormat=tmpArray[1].toLowerCase();
			}
			if (tmpArray.length > 2) {
				dataAttributeName=tmpArray[2];
			} else {
				dataAttributeName="data"
			}
			wfDebug(3,"\n\tProcessing form variable: '" + formVar + "'");
			wfDump(3,["\tformVarFormat;"+formVarFormat,"\tdataAttributeName;"+dataAttributeName,])

			var tcfData=[];
			tcfData=eval('tcfdata.'+formVar); // jshint ignore:line
			if (typeof(tcfData) === 'undefined') {
				wfDebug(3,'\t\t*** Variable ' + formVar + ' is not defined in the tcf file, skipping');
				return;
			}
			wfDump(4,["\ttcfData;"+tcfData.toSource()]);

			var tcaData=[];
			if (typeof eval('tcadata.'+formVar) != 'undefined' ) {
				tcaData=eval('tcadata.'+formVar); // jshint ignore:line
				wfDump(4,["\ttcaData;"+tcaData.toSource()]);
			}

			// Parse the data and build a refs object for the tcf and tca data
			tcfData.forEach(function(a) {
				ref=ParseRelatedData(a,formVarFormat,dataAttributeName);
				if (ref != {}) {
					ref.source="formVar:" + formVar;
					refsArray.push(ref);
					refsLookup[ref.data.toSource()]=refsArray.length-1;
				}
			});
			if (tcaData != tcfData) {
				tcaData.forEach(function(a) {
					ref=ParseRelatedData(a,formVarFormat,dataAttributeName);
					if (ref != {}) {
						ref.source="formVar:" + formVar;
						refsArray.push(ref);
						refsLookup[ref.data.toSource()]=refsArray.length-1;
					}
				});
			}

			// Scan the tca data and see if there are any elements not in the tcf data, i.e. it has been deleted
			tcaData.forEach(function(b) {
				ref=ParseRelatedData(b,formVarFormat,dataAttributeName);
				if (ref != {}) {
					if (refsLookup[ref.data.toSource()] === undefined) {
							wfDebug(3,"\t\tAdding deleted code to refsArray: " + b.toSource());
							ref.source="formVar:" + formVar;
							refsArray.push(ref);
					}
				}
			}); //tcfData

		}); //formFieldVars

	// Get the data from the eco system
		if (ecoSystemData && wfCimInstance === "courseadmin") {
			var tempArray=refsArray.concat(GetEcoSystemData(proposalCode,proposalDept,ecoSystemTypeStr))
			if (tmpArray.length != refsArray.length) {
				wfDebug(3,"\t" + tmpArray.length-refsArray.length + "items to add from the Eco system");
				refsArray=tempArray;
			} else {
				wfDebug(3,"\tZero (0) items to add from the Eco system");
			}
		}

	// Do we have any references?
		if (refsArray.length === 0) {
			wfDebug(3,"\t*** Zero (0) items to add, stopping");
			return false;
		}

	// Look up the output tokens based on how we were called (Dept, Col)
		var outToken={}, outTokens=[], steps=[], searchStr="";
		refsArray.forEach(function(ref) {
			sqlStmt='';
			resultSet=[];
			//Resolve the ref based on the substitution type
 			switch (substitutionType) {
 				case "dept":
					searchStr="Dept";
					if (tcfdata.CrosslistedDeptsSteps && tcfdata.CrosslistedDeptsSteps.length > 0)
						steps=tcfdata.CrosslistedDeptsSteps;
					if (ref.format === "dept" ) {
						outToken={};
						outToken.data=ref.data;
						outToken.source=ref.source;
						outTokens.push(outToken);
					} else if (ref.format === "subj" ) {
						resultSet=LookupCode("deptCode","subjCode",ref.data,"",proposalDept,colVarName,deptVarName,subjVarName);
					   //function LookupCode(lookupType,givenType,givenData1,givenData2,exceptData,colColumnName,deptColumnName,subjColumnName) {
					}
 					break;
  				case "college":
					searchStr="Col"
					if (tcfdata.CrosslistedCollegesSteps && tcfdata.CrosslistedCollegesSteps.length > 0)
						steps=tcfdata.CrosslistedCollegesSteps;
					if (ref.format === "col" ) {
						outToken={}
						outToken.data=ref.data;
						outToken.source=ref.source;
						outTokens.push(outToken);
					} else if (ref.format === "dept" ) {
						resultSet=LookupCode("colCode","deptCode",ref.data,"",proposalCol,colVarName,deptVarName,subjVarName);
						 //function LookupCode(lookupType,givenType,givenData1,givenData2,exceptData,colColumnName,deptColumnName,subjColumnName) {

					} else if (ref.format === "subj" ) {
						resultSet=LookupCode("colCode","subjCode",ref.data,"",proposalCol,colVarName,deptVarName,subjVarName);
					   //function LookupCode(lookupType,givenType,givenData1,givenData2,exceptData,colColumnName,deptColumnName,subjColumnName) {
					}
	 				break;
  				case "subj":
					searchStr="Subj"
					//if (tcfdata.CrosslistedCollegesSteps && tcfdata.CrosslistedCollegesSteps.length > 0)
					//	steps=tcfdata.CrosslistedCollegesSteps;
					if (ref.format === "dept" ) {
						//sqlStmt="SELECT distinct college as token FROM cimlookup WHERE department=?";
						resultSet=LookupCode("subjCode","deptCode",ref.data,"",proposalSubj,colVarName,deptVarName,subjVarName);
					   //function LookupCode(lookupType,givenType,givenData1,givenData2,exceptData,colColumnName,deptColumnName,subjColumnName) {
					} else if (ref.format === "subj" ) {
						//sqlStmt="SELECT distinct college as token FROM cimlookup WHERE subject=?";
						outToken={};
						outToken.data=ref.data;
						outToken.source=ref.source;
						outTokens.push(outToken);
					}
					sqlParms=[ref.data];
  					break;
  				default:
  					return false;
  					break;
 			}//switch

			//Process resultSet data (if any), set output array data

			if (resultSet) {
				resultSet.forEach(function(result) {
					if (result.token != "") {
						outToken={};
						outToken.data=result.token;
						outToken.source=ref.source;
						outTokens.push(outToken);
					}
				});
			} //(resultSet)



		}); //refsArray.forEach(function(ref)
		if (searchStr === "") {
  			print_debug(3,"\n\n*** Error in '" + myName + "' function in " + wfLibName +
  				" , invalid value for substitutionType ('" + substitutionType + "') *** \n\n")
			print_doc(3,"<br>*** Error in " + myName + " function in " + wfLibName +
				",<br> *** invalid value for substitutionType ('" + substitutionType + "') *** <br> ")
		}

	// Output the steps
		var retArray=[];
		// Make sure we skip any that match the proposal data
		var tokensDone=[];
		switch (substitutionType) {
			case "dept":
				tokensDone[proposalDept]=true; break;
			case "college":
				tokensDone[proposalCol]=true; break;
			case "subj":
				tokensDone[proposalSubj]=true; break;
		}//switch

		if (outTokens.length > 0 ) {
			wfDebug(3,"\n\tReturn step data for " + searchStr + "(s)...");
			// if debug envronent then add starting line in the workflow
			if (wfEnvIsDev) retArray.push("*** Start of  ' " + inval.toLowerCase().replace('optional','') + " ' output ***");
		} else {
			wfDebug(3,"\t*** No additional data found to add ***")
			if (wfEnvIsDev) return ["*** No additional 'related' data found for ' " + inval.toLowerCase().replace('optional','') + " ' ***"];
			return false;
		}

		outTokens.forEach(function(token) {
			if (token === '') return;
			// Have we seen this one yet?
			if (!tokensDone[token.data]) {
				// Do we have a full step name from the workflow or do we pull the step data from the config file
				if (inval == wfrule.searchfor) {
					if (steps.length > 0) {
						// Get steps from the config file
						steps.forEach(function(step) {
							step=step.replace(searchStr,token.data);
							// Add fyi or fyiall if notify mode or if this is eco system reference and ecoSystemDataFyi is not null
							if (ecoSystemDataFyi != '' && token.source.substr(0,3) === 'eco') {
								if (step.indexOf("fyi") < 0) step=step + ' ' + ecoSystemDataFyi;
							} else if (notifyMode) {
								if (step.indexOf(' fyi') < 0) {
									step=step + ' fyiall';
								} else if (step.indexOf(' fyi') >= 0) {
									step=step.replace(' fyi',' fyiall');
								}
							}
							retArray.push(step.trim());
							wfDebug(3,"\t\t" + retArray[retArray.length-1]);
						});	//steps
					} else {
						wfDebug(0,"\t" + myName + ": *** Error *** 'Bare' call to " + myName + " and no steps were defined");
					}
				} else {
					// We have a workflow step so substitute the data into the step name
					step=inval
					if (ecoSystemDataFyi != '' && token.source.substr(0,3) === 'eco') {
						// If the step name does not contain the string 'fyi' and ecoSystemDataFyi is true then add the 'fyi'
						if (step.indexOf("fyi") < 0 && ecoSystemDataFyi === 'true') step=step + ' fyi';
					}
					retArray.push(step.replace(wfrule.regex,token.data).trim());
					wfDebug(3,"\t\t" + retArray[retArray.length-1]);
				}
				tokensDone[token.data]=true;
			}
		}); //outTokens
		// if debug envronent then add ending line in the workflow
		if (wfEnvIsDev) retArray.push("*** End of  ' " + inval.toLowerCase().replace('optional','') + " ' output ***");
	return retArray;

}; //Related

//======================================================================================================================
// Resolve a code from the cimlookup table
// called like:
// LoookupCode lookupType,givenType,givenData,exceptData[,colColumnName,deptColumnName,subjColumnName]
// Where:
//		<lookupType>	- The type of data to lookup in the set {'collegeCode','departmentCode'}
// 		<givenType>		- The type of data provided for the query in the set {'subjectCode','departmentCode'}
// 		<givenData1>	- The value for the given data
// 		<givenData2>	- The value to exclude from the join variable.  This is only used for the
//							'lookup college given a subject', in that case it is the department value on the
//							proposal
// 		<exceptData>	- Values to exclude from the results
//							(e.g. if looking up college, this would be the proposal college)
//	optionally
//		<colColumnName>		- The column name for 'college' in the database, default is 'college'
//		<deptColumnName>	- The column name for 'department' in the database, default is 'department'
//		<subjColumnName>	- The column name for 'subject' in the database, default is 'subject'
//
//	e.g.
// LookupCode('colCode','subjectCode','AHL',,'AS')
//		returns the college code(s) for subject 'AHL' unless the college code is 'AS'
// LookupCode('colCode','subjectCode','AHL','2015','AS')
//		returns the college code(s) for subject 'AHL', factor out department '2015' from the query, unless the college code is 'AS'
// LookupCode('colCode','deptCode','AHL',,'AS','prog_coll')
//		returns the college code for department 'AHL' unless the college code is 'AS'
//		uses 'prog_coll' as the lookup column for college data
//
//======================================================================================================================
// 08/30/16 - dgs - Initial
// 11/15/16	- dgs - Re-factored to allow the specification of the column names in the database
// 12/20/16 - dgs - re-wrote the sql statement for looking up college give subject
//======================================================================================================================
function LookupCode(lookupType,givenType,givenData1,givenData2,exceptData,colColumnName,deptColumnName,subjColumnName) {
	var version='1.0.5'; var myName=arguments.callee.toString().match(/function ([^\(]+)/)[1]; var version="2.0.0"
	wfDebug(4,"\n\t*** In "+ myName + " (" + version +") ***")

	if (typeof colColumnName === 'undefined') { colColumnName="college";}
	if (typeof deptColumnName === 'undefined') { deptColumnName="department";}
	if (typeof subjColumnName === 'undefined') { subjColumnName="subject";}

	wfDebug(4,"\t\tlookupType: " + lookupType + ", \tgivenType: " + givenType +
		", \tgivenData1: " + givenData1 + ", \tgivenData2: " + givenData2 + ", \texceptData: " + exceptData +
		"\n\t\tcolColumnName: " + colColumnName + ", \tdeptColumnName: " + deptColumnName +
		", \tsubjColumnName: " + subjColumnName);

	var resultSet=[];
	var sqlStmt='';

	// MAIN
	sqlParms=[givenData1];
	if (typeof exceptData != 'undefined')
		sqlParms.push(exceptData);

	// Lookup college code
		if (lookupType.toLowerCase().substr(0,1) === "c") { // lookup college code
			if (givenType.toLowerCase().substr(0,1) === "s") { // give a subject code
				sqlParms.push(givenData2);
				sqlStmt="select distinct " + colColumnName + " from cimlookup where " + deptColumnName + " in (select " + deptColumnName +
						" from cimlookup where " + subjColumnName + "=? and " + deptColumnName + " <> ? and " + colColumnName + "<> ''";
				if (typeof exceptData != 'undefined') {
					sqlStmt= sqlStmt + " and " + colColumnName + "<> ?";
					sqlParms.push(exceptData);
				}
				sqlStmt= sqlStmt + " order by " + colColumnName;

			} else if (givenType.toLowerCase().substr(0,1) === "d") { // give a department code
					sqlStmt="select distinct " + colColumnName + " as token from cimlookup where " + deptColumnName +
							" = ? and " + colColumnName + " <> '' ";
					if (typeof exceptData != 'undefined')
						sqlStmt= sqlStmt + " and " + colColumnName + " <> ?";
			}
		}

	// Lookup department code
		if (lookupType.toLowerCase().substr(0,1) === "d") { // lookup department code
			if (givenType.toLowerCase().substr(0,1) === "s") { // give a subject code
				sqlStmt="select distinct " + deptColumnName + " as token from cimlookup where " + subjColumnName +
						" = ? and " + deptColumnName + " <> '' ";
				if (typeof exceptData != 'undefined')
					sqlStmt=sqlStmt + " and " + deptColumnName + " <> ?";
				}
		}

	// If we do not have sqlStmt set then something is wrong
		if (sqlStmt === '' ) {
			wfDebug(0,"*Error* -- " + myName + ": Invalid type ('" + type + "') passed to function")
			return false;
		}

	// Run query
		wfDump(4,["\tsqlStmt;"+sqlStmt,"\tsqlParms;"+sqlParms.toSource()])
		resultSet=dbquery("cimcourses",sqlStmt,sqlParms);
		wfDump(4,["\tresultSet;"+resultSet.toSource()])

    return resultSet;
} //LookupCollegeCode


//=================================================================================================
// Return additional steps for all 'equiv' courses in courseref table
//=================================================================================================
wffuncs.AddSameAs = function(inval, wfrule, args) {
	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (haveDebug) Debug('\n*** In '+ myName + " called as '" + wfrule.searchfor + ", Step: '" + inval +"' ***");
	//if (haveDebug) { Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); }

	var retArray=[];
	//Try block encapsulated main function
	 try {
		// Initial Checks
			if(args && args.context && args.context != "wfrule")
		 		throw "\t*** Failed rule type check";
			if(!tcfdata.code || !tcfdata.code.length)
		 		throw "\t*** Failed tcfdata.code is not null check";
			if(!tcfdata.department || !tcfdata.department.length)
		 		throw "\t*** Failed tcfdata.department is not null check";
			if(!tcfdata.college || !tcfdata.college.length)
		 		throw "\t*** Failed tcfdata.college is not null check";

	 	// Main
			var reqType=wfrule.searchfor.toLowerCase();

			// Get proposal data
				var parentCode=tcfdata.code[0];
				var proposalSubj=tcfdata.subject[0].code;
				var proposalDept=tcfdata.department[0].code;
				var proposalCol=tcfdata.college[0].code;
				if (haveDebug) { Dump('reqType',reqType); Dump('parentCode',parentCode); Dump('proposalCol',proposalCol); Dump('proposalDept',proposalDept); }

			// Lookup the equiv course from coursref
			var refSubj;
			sqlStmt="SELECT DISTINCT path,dept FROM courseref WHERE code = ? AND dept <> ? AND dept <> '' and type = 'equiv'";
			sqlParms=[parentCode,proposalDept];
			resultSet1=dbquery("courseref",sqlStmt,sqlParms);
			resultSet1.forEach(function(courserefResult) {
				if (haveDebug) { Debug('\t Equiv result = >' + courserefResult.toSource() + '<\n'); }
				refSubj=courserefResult.dept;
				if (haveDebug) { Dump('\t\t refSubj',refSubj); }
				if (reqType.indexOf('depts') > 0) {
					sqlStmt="SELECT DISTINCT department 'token' FROM cimlookup WHERE subject = ? AND department <> ? AND department <> ''";
					sqlParms=[refSubj,proposalDept];
				} else {
					sqlStmt="SELECT DISTINCT college as 'token' FROM cimlookup WHERE subject = ? AND college <> ? AND college <> ''";
					sqlParms=[refSubj,proposalCol];
				}
				//print_debug('\t\t sqlStmt = >' + sqlStmt + '<\n');
				resultSet2=dbquery("cimcourses",sqlStmt,sqlParms);
				resultSet2.forEach(function(cimlookupResult) {
					if (haveDebug) { Dump('cimlookupResult',cimlookupResult.toSource()); }
					retArray.push(inval.replace(wfrule.regex,cimlookupResult.token))
				}); //resultSet2
			}); //resultSet1

		// return steps if found or false if none added
		if (retArray.length > 0) {
			if (haveDebug) { retArray.forEach(function(step) { print_debug('\t Returning step:  >' + step + '<\n'); }); }
			return retArray;
		} else {
			return false;
		}

	} //Try block
	//Catch block for errors thrown in above try block
	catch(err) { print_debug(wfrule.attrname + ": " + err) ; return false; }
	return false;  // Should never get here
} //AddSameAs

//Set include SIS step on (true) or off (false) -- only applys to DEV env.
//addSisEnvs:test,next
//wfrules:SISsync|function|AddSisStep|
//=========================================================================================================================
// Pull the sisName value in the config file and replace that in the workflow, include in workflow if
// not running.  Only add sissync step if current env is in 'tcfdata.addSisEnvs'
// ??/??/2014 - dgs - New
// 02/26/2015 - dgs - Refactored to move sisname = '' warning earlier, add sisname to other messages
// 01/25/2016 - dgs - Refactored check env in addSisEnvs
//=========================================================================================================================
wffuncs.AddSisStep = function(inval, wfrule, args) {
	// setup
	var version='1.0.5'; var myName=wfrule.attrname;
	// Check execution env
	if(args && args.context && args.context != "wfrule")
		return false;

	// Get sisname from cimconfig.cfg
	if (tcfdata.sisname === '') {
		var spaceing='&nbsp;&nbsp;&nbsp;&nbsp;';
		print_doc(spaceing + '<strong>*Error* -- (' + myName + ') Default SIS name not set in cimconfig.cfg file.<br>' + spaceing + 'Please contact your CourseLeaf Administrator.</strong>');
		wfDebug(3,'\t *Error* -- Default SIS name not set in cimconfig.cfg file.');
		return false;
	}

	if (typeof tcfdata.wfAddSisEnvs == "undefined") {
		wfDebug(3,"\t*Warning* -- tcfdata.addSisEnvs undefined, adding sis sync step");
		return tcfdata.sisname.toString().trim();
	}

	if (tcfdata.wfAddSisEnvs[0].indexOf(GetEnv().toString()) < 0){
		print_doc("&nbsp;&nbsp;&nbsp;<strong><em>*Warning*</strong> -- (" + myName + ") Not including SIS Sync step (" + tcfdata.sisname + ")");
		print_doc("<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp" +
			"env = " + GetEnv().toString() + " and wfAddSisEnvs = '" + tcfdata.wfAddSisEnvs + "'" );
		return false;
	}

	// Add SIS Sync Step
	wfDebug(3,'\tAdding SIS Sync step: ' + tcfdata.sisname.toString().trim());
	return tcfdata.sisname.toString().trim();

}; //AddSisStep

//==================================================================================================
// Check the proposal mode
// 09/10/2015 - dgs - New
//==================================================================================================
wffuncs.CheckProposalMode = function(inval, wfrule, args) {
	var version='1.0.5'; var myName=wfrule.attrname; wfDebug('\n*** In '+ myName + "(" + version + ") called as '" + wfrule.searchfor + "' ***");
	var reqType=wfrule.searchfor.toUpperCase();
 	var propMode = GetProposalMode();
	//wfDump(['reqType;'+reqType,'propMode;'+propMode])

	if (reqType.indexOf(propMode) >= 0) {
		wfDebug("\t*** Including step")
		return [inval.replace(wfrule.ifregex,'')];
	}

	return false;

}; //CheckProposalMode

//==================================================================================================
//==================================================================================================
// Common utilities
//==================================================================================================
//==================================================================================================

//==================================================================================================
// Return data from the eco system for this course
// returns an array of reference objects, each reference object is of the form:
// {ref:data ref:dept ref:format}
// format is in {'subj','dept','path'}
//==================================================================================================
// 07/13/16 -- dgs -- Initial
// 07/27/16 -- dgs -- Remove duplicates before returning data
//==================================================================================================
function GetEcoSystemData(parentCode,proposalDept,ecoSystemTypeStr) {
	if (parentCode == "" || proposalDept == "") return false;
	var tmpArray=parentCode.split(' ');
	var proposalSubj=tmpArray[0];
	//wfDump(['parentCode;'+parentCode,'proposalDept;'+proposalDept,'proposalSubj;'+proposalSubj]);

	var refsArray=[];
	//Check for any cross references data for this course in the crossref table (eco system)
		var sqlStmt="SELECT DISTINCT path,dept,type FROM courseref WHERE code = ? AND dept <> ? AND dept <> ''";
		if (typeof(ecoSystemTypeStr) != 'undefined'  ) {
			if (ecoSystemTypeStr != false || ecoSystemTypeStr != "") {
				sqlStmt=sqlStmt + ' AND type IN ' + ecoSystemTypeStr
			}
		}

		var sqlParms=[parentCode,proposalDept];
		//wfDump(['sqlStmt;'+sqlStmt,'sqlParms;'+sqlParms.toSource()]);
		var resultSet=dbquery("courseref",sqlStmt,sqlParms);
		var checkArray=[];
		resultSet.forEach(function(result) {
			var ref={};
			if (result.path.substr(0,1) === '/') {
				if (result.dept != proposalDept) {
					ref.source='eco-cat';
					ref.data=result.dept;
					ref.format='dept';
					ref.type=result.type;
				}
			} else if (result.path.substr(0,12) === 'programcode:') {
				if (result.dept != proposalDept) {
					ref.source='eco-program';
					ref.data=result.dept;
					ref.format='dept';
					ref.type=result.type;
				}
			} else if (result.path.substr(0,5) === 'code:') {
				if (result.dept != proposalSubj) {
					ref.source='eco-course';
					ref.data=result.dept;
					ref.format='subj';
					ref.type=result.type;
				}
			}
			var key=ref.source+ref.data+ref.format+ref.type
			if (Object.keys(ref).length != 0 && typeof checkArray[key] === 'undefined') {
				refsArray.push(ref); checkArray[key]=true;
			}
		}); //resultSet

		wfDebug(4,"\n\tFound " + refsArray.length.toString() + " distinct references found from the Eco System")
		refsArray.forEach(function(ref) { wfDump(['\tref;'+ref.toSource()]); });

	return refsArray;
}

//=================================================================================================
// Check to see if the list of variables passed in have changed or not.  The options string passed
// on the wfrule definition should be of the form:
//		mode:<mode> fields:<fieldList>
// where
//		mode='only' or 'any', 'only' will allow the step if only those fields listed in the fieldList
//				have changed.  'any' will allow the step if any of the fields have changed.
//e.g.
//	wfrules:isMinorChange|function|CheckChanged|mode:only fields:description,long_title,prop_title|; // Minor change
//=================================================================================================
// 03-10-17 - dgs - Initial coding -- ???
//=================================================================================================
wffuncs.CheckChanged = function(inval, wfrule, args) {
	var myName=wfrule.attrname;
	var version='1.0.5'; wfDebug("\n*** In " + myName + "(" + version + ") called as '" + wfrule.searchfor + "', Step: '" + inval + "' ***");
	var retArray=[];
	var reqType=wfrule.searchfor.toLowerCase();

	//Initial Checks
	try {
		InitialChecks(["wfrule"],args)
	} //try
	catch(err) { print_debug('\t' + myName + ": " + err + "\n") ; return false; }

	// Main
		// Parse off the wfrule.options value
			var tmpArray=wfrule.options.split(" ");
			var mode=tmpArray[0];
			var checkFields=tmpArray[1];
			tmpArray=mode.split(':');
			mode=tmpArray[1];
			tmpArray=checkFields.split(':');
			checkFields=tmpArray[1].split(",");
			wfDump(["wfrule.options;"+wfrule.options,"mode;"+mode,"checkFields;"+checkFields])

		// Get the changed fields
			var diffdata = {};
			tcfview.compare(tcfdata.key[0], {addwarnings: false, retdata: diffdata});
		// loop through changed values Setup a lookup has for each variable in the 'changed' list
			var changedHash={};
			for (var key in diffdata) {
			    if (!diffdata.hasOwnProperty(key)) continue;
			 	changedHash[key]=true;
			}
			wfDump(3,["changedHash;"+ changedHash.toSource()])
		// Loop through the checkFields array to see if it is in the changed list
			var allInList=true;
			var oneInList=false;
			checkFields.forEach(function(field) {
				if (typeof changedHash[field] != "undefined") {
					if (changedHash[field] === true) {
						oneInList=true
						wfDebug(3,"\t\t" + field + " has changed")
					} else { allInList=false; }
				}
			});
			wfDump(3,["oneInList;"+ oneInList,"allInList;"+ allInList])

		var allowStep=false;
		if (mode === 'only' && allInList === true && changedHash.length === checkFields.length)
			allowStep=true;
		if (mode === 'any' && oneInList === true)
			allowStep=true;

	// Return results
		if(allowStep) {
			wfDebug(0,"\t*** Allowing step")
			return [inval.replace(wfrule.ifregex,'')];
		}
		wfDebug(0,"\t*** Skipping step")
		return false

} //CheckChanged

///==================================================================================================
// Initial Checks
// Input is an array of variable names and the the std wffuncs 'args' variable.
// Will check to make sure each element of the array is not undefined and has a non-null value
// If the variable name is 'wforder' or 'wfrule' then it will check agains the 'args' data to make
// verify the call type.
// e.g. InitialChecks(["wforder","code","department"],args);
//==================================================================================================
InitialChecks = function(checkVars,args) {
	wfDebug(4,"\n*** In InitialChecks ***");
	var tcfData={};
	wfDump(4,['args;'+args.toSource()]);

	for (var i=0,  tot=checkVars.length; i < tot; i++) {
		var checkVar=checkVars[i];
		wfDump(4,["checkVars[" + i + "];"+checkVar]);
		if (checkVar === "wfrule" || checkVar === "wforder") {
			if (args && args.context && args.context != checkVar)
		 		throw "*** Failed rule type='" + checkVar + "'' check";
		 	wfDebug(4,"\t\tValue OK");
		} else {
			tcfData=eval('tcfdata.'+checkVar); // jshint ignore:line
			//Dump('\t\ttcfData',tcfData);
			if (typeof tcfData === "undefined")
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is undefined";
			if (tcfData == null)
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is not null check(1)";
			if (tcfData == "")
				throw "*** Failed 'InitialChecks', variable 'tcfdata."+ checkVar + "' is not null check(2)";
		}
		wfDebug(4,"\t\tHas value");
	} //for loop
	return;
} //InitialChecks


//==================================================================================================
// Return the proposal mode
// 02/26/2015 - dgs - New
//==================================================================================================
GetProposalMode = function() {
	wfDebug(4,"\n*** In GetProposalMode ***");
	var retVal='EDIT';
	if (tcfdata.newrecord && tcfdata.newrecord.length) {
		if (tcfdata.newrecord == 'true')
			retVal='NEW';
	}
	if (tcfdata.deleterec && tcfdata.deleterec.length) {
		if (tcfdata.deleterec == 'true')
			retVal='DELETE';
	}

	wfDebug(4,"\t*** Proposal mode: " + retVal);
	return retVal;

}; //GetProposalMode

// //==================================================================================================
// // Helper function to check changed fields against a list of fields to see if:
// // Usage:
// //	CheckChanged(<changedFields>,<checkFields>][,<mode>,<quiet>])
// //
// //	mode 	- In the set of {"only","any"}
// // 			mode=only 	- true if ALL of the changed fields are in the list
// // 			mode=any 	- true if ANY of the change fields are in the list
// //
// // changedField is an array of the changed fields
// // checkFields is an array of the fields to check
// //===================================================================================================
// // 02/16/15	- dgs - New
// // 10/12/15 - dgs - simplified logic
// // 04/19/16 - dgs - Fix logic for 'ONLY'
// // 11/16/16 - dgs - Do not throw error if diff data is null, return false
// // 12/08/16 - dgs - Complete re-write
// //===================================================================================================
// function CheckChanged(changedFields,checkFields,mode,quiet) {
// 	var myName='CheckChanged'; wfDebug(3,"\n\t*** In "+ myName + " ***");

// 	//Try block encapsulated main function
// 	try {
// 		// Initial Checks
// 			if (arguments.length < 2)
// 		 		throw "\t*** Insufficinent arguments passed in";

// 			if (changedFields.length === 0)
// 				throw "*Error* -- 'changedFields' is zero length"

// 		// Main
// 			var retVal = false;
// 			mode=mode.toLowerCase();
// 			wfDump(3,["\tmode;"+mode,"\tcheckFields;"+checkFields.toSource(),"\tchangedFields;"+changedFields.toSource()]);

// 			// Loop thorough the changedFields setting a hash table
// 				var changedHash={};
// 				changedFields.forEach(function(field) { changedHash[field]=true; });
// 				wfDump(3,["\tchangedHash;"+ changedHash.toSource()])

// 			// Loop thorough the cycleattrs setting a hash table entry for any field that has a non null value
// 				var cycleattrsHash={}, attrVal;
// 				tcfdata.cycleattrs.forEach(function(attr) {
// 					attrVal=eval('tcfdata.' + attr); //wfDump(0,["attr;"+attr,"attrVal;"+attrVal])
// 					if (attrVal == "") cycleattrsHash[attr]=true;
// 				});
// 				wfDump(3,["\tcycleattrsHash;"+ cycleattrsHash.toSource()]);
// 			// ANY
// 				if (mode == "any") {
// 					// Loop thorough the checkField list
// 					checkFields.forEach(function(field) {
// 						if (changedHash[field])
// 							retVal=true;
// 					});
// 				}
// 			// ONLY
// 				if (mode == "only") {
// 					// Loop through the changed fields to make sure they are all on the checkFields list
// 					var retVal=true;
// 					changedFields.forEach(function(chgField) {
// 						wfDump(4,["\tchgField;"+chgField])
// 						if (!cycleattrsHash[chgField]) {
// 							var found=false;
// 							checkFields.forEach(function(chkField) {
// 								wfDump(4,["\t\tchkField;"+chkField])
// 								if (chkField === chgField) found=true;
// 							});
// 							wfDump(4,["\t\t\tfound;"+found])
// 							retVal=retVal&&found;
// 						} else {
// 							wfDebug(4,"\t\t\tField is on cycleattrs list and is null, skipping checks")
// 						}
// 					});
// 				} // Only
// 			// Return
// 				wfDump(3,["\tretVal;"+retVal]);
// 				return retVal;

// 	 } //try block
// 	catch(err) { wfDebug(err); return false; }	// Should never get here

// } //CheckChanged

// //=================================================================================================
// // Check if a variable values have changed or not (based on called step name)
// // changed or not changed determined by the step name, if step name includes 'not' then 'not changed'
// // variable name is passed in in the options specified on the wfrule definition
// // Needed since the 'haschanges' rule for iffieldmatch does not fire if data is missing on one side
// //=================================================================================================
// // 11-10-16 - dgs - Initial coding -- MIT
// //=================================================================================================
// wffuncs.CheckVarValChanged = function(inval, wfrule, args) {
// 	var myName=wfrule.attrname; var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
// 	if (haveDebug) Debug('\n*** In '+ myName + " called as '" + wfrule.searchfor + ", Step: '" + inval +"' ***");
// 	//if (haveDebug) { Dump('\tinval',inval); Dump('\twfrule',wfrule.toSource()); Dump('\targs',args.toSource()); }

// 	//Try block encapsulated main function
// 	 try {
// 		// Initial Checks
// 			InitialChecks(["wfrule"],args)
// 	} //Try block
// 	//Catch block for errors thrown in above try block
// 	catch(err) { print_debug('\t' + myName + ": " + err + "\n") ; return false; }

// 	var calledAs=wfrule.searchfor;
// 	var reqType=calledAs.toLowerCase();
// 	// Parse the variable name from the options field on the wfrule definition
// 	var tmpArray=wfrule.options.split(";");
// 	var varName=tmpArray[0];

// 	// Main
// 		//Get a list of fields that have changed
// 		var diffdata = {};
// 		tcfview.compare(tcfdata.key[0], {addwarnings: false, retdata: diffdata});

// 		var changed = CheckChanged(diffdata,[varName],"any",true);

// 		if (reqType.indexOf('not') >=0 ) {
// 			if (! changed) {
// 				wfDebug("\t *** Conditions met for: " + varName + ", including step")
// 				return [inval.replace(wfrule.ifregex,'')];
// 			}
// 		} else {
// 			if (changed) {
// 				wfDebug("\t *** Conditions met for: " + varName + ", including step")
// 				return [inval.replace(wfrule.ifregex,'')];
// 			}
// 		}

// 		wfDebug("\t *** Conditions not met for: " + varName + ", skipping step")
// 		return false
// } //CheckScienceCoreChanged

//==================================================================================================
// Check execution environment, passed one argument 'env' that can hav values 'dev' or 'test'
// compares execution url (host) against arg and if there is a match then returns true, otherwise
// returns false
//==================================================================================================
EnvIs = function(env) {
	var host=getenv("HTTP_HOST").toUpperCase() ;
	if (env.toUpperCase() == 'DEV' && host.indexOf('.DEV') > 0)
			return true;
	if (env.toUpperCase() == 'TEST' && host.indexOf('-TEST.') > 0)
			return true;
	if (env.toUpperCase() == 'NEXT' && host.indexOf('-NEXT.') > 0)
			return true;
	return false;
}; //EnvIs
GetEnv = function(env) {
	var host=getenv("HTTP_HOST").toLowerCase() ;
	if (host.indexOf('.dev') > 0) {
			return 'dev';
	} else if (host.indexOf('-test') > 0) {
			return 'test';
	} else if (host.indexOf('-next') > 0) {
			return 'next';
	}
	return '*unknown*';
} //EnvIs


//==================================================================================================
// Quick formatted print of a variable
//==================================================================================================
function Dump(varName,varValue) { print_debug(varName + " = '" + varValue.toSource() + "'\n"); } //Dump
function dump(varName,varValue) { Dump(varName,varValue); }
function Here(id) { print_debug('Here ' + id + '\n'); } //Here
function here(id) { Here(id); }

//==================================================================================================
// Print a formatted debug message if current ennvironment is on the tcfdata.debugEnvs list.
// Passed 3 arguments:
// <msgLevel>	--	The level of the message, default is 0
// string 		-- The text to print
// mode 		-- The mode ('S' for screen, 'D' for wizdebug), default is 'D'
//==================================================================================================
// 07/22/16 -- dgs -- Initial
// 08/30/16	-- dgs -- Added msglevel
//==================================================================================================
var wfDumpTabLevel=0;
function wfDebug(msgLevel,text,mode){
	// Should we run
	if (typeof wfDebugEnvs === "undefined") return;
	if (typeof wfDebugEnvs === "") return;
	if (!wfInDebugEnv) return;

	// Set variables if this is not a full call
	if (typeof msgLevel != 'number') {
		text=msgLevel;
		msgLevel=0
	}
	if (msgLevel > wfDebugLevel) return;

	// set Mode
		if (typeof mode === 'undefined') mode="D"
		mode=mode.toUpperCase();
	// Print message
		if ( mode == 'D' || mode == 'B' )
			print_debug(text + ' \n');
		if ( mode == 'S' || mode == 'B' )
			print_doc("&nbsp;&nbsp;&nbsp;" + text + ' <br>');
	return;
} //Debug

//=================================================================================================
// Formatted print an list of variables, is passed 3 arguments:
// <msgLevel>		--	The level of the message, default is 0
// [array]			-- 	Each element is of the form 'variableName<delimiter>variableValue'
// <'delimiter'>	-- 	The delimiter char to seperate name from value, default is ';'
//=================================================================================================
// 07/22/16 -- dgs -- Initial
// 08/30/16	-- dgs -- Added msglevel
//==================================================================================================
function wfDump(msgLevel,varList,delimiter){
	// Shoud we run
	if (typeof wfDebugEnvs === "undefined") return;
	if (typeof wfDebugEnvs === "") return;
	if (!wfInDebugEnv) return;

	// Set variables if this is not a full call
	if (typeof msgLevel != 'number') {
		varList=msgLevel;
		msgLevel=0
	}
	if (msgLevel > wfDebugLevel) return;

	var showAsSource=false
	if (typeof varList != 'object') { print_debug("*Error* -- wfDump: invalid argument type\n"); return;}
	if (typeof delimiter === 'undefined') delimiter=";"
	if (delimiter.toLowerCase().substr(0,1) === "s") {
		showAsSource=true
		delimiter=";"
	}

    varList.forEach(function(v) {
    	var tokenArray=v.split(delimiter);
    	if (showAsSource) {
     		wfDebug("\t"+ tokenArray[0] + ' = >' + tokenArray[1].toSource() + '<');
    	} else {
    		wfDebug("\t"+ tokenArray[0] + ' = >' + tokenArray[1] + '<');
    	}
    });
} //wfDump

//==============================================================================================
// Helper function to check to see if a variable has a value, if not then print a message and return false
// e.g. if (! CheckForVal(tcfdata.rotation,'Course Rotation',ChangeTypeFirstRun)) { ChangeTypeFirstRun=false; return false; }
//==============================================================================================
function CheckForVal(varName,varValue) {
	//print_debug('\tvarName = ' + varName + ', varValue =' + varValue + ',varValue.length  = ' + varValue.length + '\n');
	if (!varValue || !varValue.length) {
		print_doc('&nbsp;&nbsp;<strong>*WARNING*</strong> -- Data Field&nbsp;&nbsp;<em>\'' + varName + '\'</em>&nbsp;&nbsp;does not have a value, workflow calculation incomplete.<br>');
		return false;
	}
	return true;
} //CheckForVal

//==================================================================================================
// Helper function to remove duplicates from an array
//==================================================================================================
function RemoveDupes(arr,exclude) {
    var noDupes=[];
    exclude=' ' + exclude + ' ';
    arr=arr.sort();
    arr.forEach(function(value) {
		//if (typeof(Dump) == "function") { var num=noDupes.indexOf(value); Dump('\t\tIn Remove Dupes, index of ' + value + ' in input array',num); }
        if ( noDupes.indexOf(value) == -1 && exclude.indexOf(' '+value+' ') < 0 ) {
            noDupes.push(value);
        }
    });
    return noDupes;
} //RemoveDupes

//==================================================================================================
// Helper function to output the list of fields that have changed
// runs as a wforder directive
// 12/17/2014 -- dgs -- Updated for new Debug / Dump syntax
// 01/12/2015 -- dgs -- Tewaked the output format to the screen
// 02/10/2015 -- dgs -- Exit if not running in dev
//==================================================================================================
if(typeof WhatsChangedFirstRun == "undefined") var WhatsChangedFirstRun = true;
wffuncs.WhatsChanged = function(inval, wfrule, args) {
	if (!WhatsChangedFirstRun) return false;
	var haveDebug=false; if (typeof(Dump) == "function" && typeof(Debug) == "function") haveDebug=true;
	if (!haveDebug) return false;
	if (!WhatsChangedFirstRun) return false;
	var myName=wfrule.attrname;
	Debug('\n*** In ' + myName + ' ***');

	//Get a list of fields that have changed
	var diffdata = {};
	tcfview.compare(tcfdata.key[0], {addwarnings: false, retdata: diffdata});

	if (!Object.keys(diffdata).length) {
		Debug('\tNo Changes found in form data','b');
	} else {
		Debug('\t<strong><em>Changed Fields:</em></strong>','s');
		Debug('\tChanged Fields:','d');
		for (var i in diffdata) {
			Debug('\t\t' + i.toString() + ' (' + eval('tcfdata.' + i + '.toSource()') + ')','d');  // jshint ignore:line
			Debug('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp' + i.toString(),'s');
		}
	}

	WhatsChangedFirstRun = false;
	return false;
}; //wffuncs.WhatsChanged

//==================================================================================================
// Helper function to output tcfdata values in source() format
// runs as a wforder directive
// 		wfrules:wfDumpVars|function|wfDumpVars|
// 		wforder:wfDumpVars cl_subject,other_depts,sponsors
// 03/08/2017 -- dgs -- New
//==================================================================================================
wffuncs.wfDumpVars = function(varList) {
	var varArray=varList.split(" ");
	varArray=varArray[1].split(",");
	print_debug("\n")
	varArray.forEach(function(a) {
		print_debug(a + " = " + eval("tcfdata."+a).toSource() + "\n");
	});
	print_debug("\n")
	return false;
}; //wffuncs.wfDumpVars

//==================================================================================================
// END
//==================================================================================================
if (wfEnvIsDev && !wfLibLoaded) print_debug("\n\t" + wfLibName + " loaded\n");
var wfLibLoaded=true;
