#!/bin/bash
# XO NOT AUTOVERSION
#=======================================================================================================================
version="4.0.0" # -- dscudiero -- Wed 10/17/2018 @ 08:09:34
#=======================================================================================================================

function Main {
	Hello
	Msg "Site directory: $siteDir \nData File: $dataFile\n^Skip nulls: $skipNulls\n^Ignore missing pages: $ignoreMissingPages"
	[[ $informationOnlyMode == true ]] && Msg "^*** Information Mode Only ***"
	
	## Install the stepfile to update the page data
	if [[ $informationOnlyMode == false ]]; then
		Msg "\nCopying step file ($step)..."
		cgiOut="$(mkTmpFile)"
		## Find the step file to run
		srcStepFile="$(FindExecutable -step "$step")"
		[[ -z $srcStepFile ]] && Terminate "Could locate the source step file ('$step')"
		Info 0 1 "Using step file: $srcStepFile"
		## Copy step file to localsteps
		stepFile=$siteDir/web/courseleaf/localsteps/$step.html
		cp -fP $srcStepFile $stepFile
		chmod ug+w $stepFile
	fi

	numPagesUpdated=0
	pushd "$siteDir/web/courseleaf" >2 /dev/null

	numRecs=$(wc -l "$dataFile"); numRecs="${numRecs%% *}"
	notifyThreshold=$(($numRecs / 6))

	Msg "\nParsing data file, $numRecs records..."
	while read -r line || [[ -n "$line" ]]; do
		line="$(tr -d "\r" <<< "$line")"
		[[ -z $line || ${line:0:10} == "(Generated" ]] && continue;
		data="$(tr "\t" '|' <<< "$line")"
		pagePath="${data%%|*}"; data="${data#*|}";
		pageTitle="${data%%|*}"; data="${data#*|}";
		pageOwner="${data%%|*}"; data="${data#*|}";
		pageWorkflow="${data%%|*}"; data="${data#*|}";
		Dump -1 -n line -t pagePath pageTitle pageOwner pageWorkflow
		if [[ -n $pageOwner ]]; then
			chkMsg="$(CheckPageOwner "$pageOwner")"
			[[ -n $chkMsg ]] && Error 0 1 "$pagePath, $chkMsg"
		fi
		if [[ -n $pageWorkflow ]]; then
			chkMsg="$(CheckPageWorkflow "$pageWorkflow")"
			[[ -n $chkMsg ]] && Error 0 1 "$pagePath, $chkMsg"
		fi

		## If not information only mode then update the page
		if [[ $informationOnlyMode == false ]]; then
			if [[ $pageOwner != '' || $pageWorkflow != '' || $skipNulls == false ]]; then
				## export the data to make it available to the step, then run step to update page data
				export QUERY_STRING="owner=$pageOwner|workflow=$pageWorkflow|skipNulls=$skipNulls"
				## Run the step
				$DOIT ProtectedCall "RunCourseLeafCgi "$siteDir" "$step $pagePath""				
				# { ( ./courseleaf.cgi $step $pagePath ); } &> $cgiOut
				# grepStr="$(grep -m 1 'ATJ error:' $cgiOut)"
				# [[ $grepStr != '' ]] && Terminate "ATJ errors were reported by the '$step' step.\n^^$grepStr"
				((numPagesUpdated +=1))
				[[ $(($numPagesUpdated % $notifyThreshold)) -eq 0 ]] && Msg "^Processed $numPagesUpdated out of $numRecs"
			fi
		fi
	done < "$dataFile"

	Msg "^Processed $numRecs out of $numRecs\n\nDone\n"
	popd >2 /dev/null

	return 0
} ## Main

function Usage {
	Error "$1"
	Msg "Usage: $myName -siteDir \"siteDir dirName\" -dataFile \"dataFile fileName\""
	Msg "^^siteDir dirName -- The fully qualified path to the courseleaf site's root directory (just above /web)"
	Msg "^^dataFile fileName -- The fully qualified name to the load data as generated by 'workwith'"
	Goodbye -3
}

#=======================================================================================================================
function Initialization {
	USELOCAL=true;
	#source "$TOOLSPATH/lib/Import.sh";
	Import "Colors Msg Dump Here MkTmpFile Hello FindExecutable ProtectedCall CourseleafUtilities"

	skipNulls=false;
	ignoreMissingPages=true;
	step='setPageData';
	## Parse defaults
	while [[ $# -gt 0 ]]; do
	    [[ $1 =~ ^-data|--datafile$ ]] && { dataFile="$2"; shift 2; continue; }
	    [[ $1 =~ ^-site|--siteDir$ ]] && { siteDir="$2"; shift 2; continue; }
	    [[ $1 =~ ^-info|--informationMode$ ]] && { informationOnlyMode=true; }
	    [[ $1 =~ ^-skip|--skipNulls$ ]] && { skipNulls=true; }
	    [[ $1 =~ ^-ignore|--ignoreMissingPages$ ]] && { ignoreMissingPages=true; }
	   	[[ $1 =~ ^-v.$ ]] && { verboseLevel=${1:2}; }
	    shift 1 || true
	done

	## Check arguments
		[[ -z $dataFile ]] && { Usage "No value specified for data file"; }
		[[ ! -r $dataFile ]] && { Terminate "The data file specified, '$dataFile', is not a file or could not be located"; }
		[[ -z $siteDir ]] && { Usage "No value specified for siteDir"; }
		[[ ! -d $siteDir ]] && { Terminate "The siteDir specified, '$siteDir', is not a directory or could not be located"; }

	## Get the list of roles
		local rolesFile="$siteDir/web/courseleaf/roles.tcf"
		[[ ! -r $rolesFile ]] && Terminate "Could not read the roles file: '$rolesFile'"
		while read line; do
			if [[ ${line:0:5} == 'role:' ]]; then
				line="${line#*:}";
				role="${line%%|*}";
				[[ -z $role ]] && continue
				roles["$role"]=true;
	      	fi
		done < "$rolesFile"
		#Msg "\nRoles:"; for mapCtr in "${!roles[@]}"; do echo -e "\tkey: '$mapCtr', value: '${roles[$mapCtr]}'"; done;

	## Get the list of userids
		pushd "$siteDir/db" >2 /dev/null
		readarray -t resultSet <<< "$(sqlite3 ./clusers.sqlite "select userid from users;" 2>&1)"
		for result in ${resultSet[@]}; do
			userids["$result"]=true
		done
		#Msg "\nUserids:"; for mapCtr in "${!userids[@]}"; do echo -e "\tkey: '$mapCtr', value: '${userids[$mapCtr]}'"; done;
		popd >2 /dev/null

	## Get the list of workflows
		local workflowFile="$siteDir/web/courseleaf/workflows.tcf"
		[[ ! -r $workflowFile ]] && Terminate "Could not read the workflow file: '$workflowFile'"
		while read line; do
			if [[ ${line:0:9} == 'workflow:' ]]; then
				line="${line#*:}";
				workflow="${line%%|*}";
				[[ -z $workflow ]] && continue
				workflows["$workflow"]=true
	      	fi
		done < "$workflowFile"
		#Msg "\nWorkflows:"; for mapCtr in "${!workflows[@]}"; do echo -e "\tkey: '$mapCtr', value: '${workflows[$mapCtr]}'"; done;

	return 0
} ## Initialization

#=======================================================================================================================		
function CheckPageOwner {
	local array IFS found
	IFS=',' read -r -a array <<< "$@"
	found=false;
	for token in "${array[@]}"; do
		[[ ${roles["$token"]+abc} ]] && { found=true; break; }
		[[ ${userids["$token"]+abc} ]] && { found=true; break; }
	done
	[[ $found == false ]] && Msg "could not resolve owner: '$token'"

	return 0
} ## CheckPageOwner

#=======================================================================================================================
function CheckPageWorkflow {
	local array IFS found
	IFS=',' read -r -a array <<< "$@"
	found=false;
	for token in "${array[@]}"; do
		[[ ${workflows["$token"]+abc} ]] && { found=true; break; }
		[[ ${roles["$token"]+abc} ]] && { found=true; break; }
		[[ ${userids["$token"]+abc} ]] && { found=true; break; }
	done
	[[ $found == false ]] && Msg "could not resolve workflow: '$token'"

	return 0
} ## CheckPageWorkflow

#=======================================================================================================================
TrapSigs 'on'
declare -A roles
declare -A workflows
declare -A userids

Initialization "$@"
Main
exit

#=======================================================================================================================
## Check-in log
#=======================================================================================================================
## 10-17-2018 @ 08:10:22 - 4.0.0 - dscudiero - Completely refactored to work with workwith tool
