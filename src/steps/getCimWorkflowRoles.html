
%spidercode%

//============================================================================================================
//use this step to generate output to be pasted into Excel
// 11/17/15 - dgs - Added ignoresteps
// 08/09/16 - dgs - Added enumeration wfSubRules
// 06/08/17 - dgs -	Updated roles to filter out functions unless the function is a substitution variable name
// 08/08/17 - dgs -	Added call back to the code mapping functions if defined.
// 08/08/17 - dgs -	Add the cim instance name to the output, if the value was mapped also include the unmapped value.
// 08/25/17 - dgs -	make sure that we add the real departement code to the subruleshash even if it is not mapped.
// 08/30/17 - dgs -	Clean up debug messaging, fix problem adding the raw step text to the output array
// 09/13/17 - dgs -	Added 'optional' flag on the reported instance name
// 02/19/18 - dgs - Update to handle multiple substitution variables in a single step name
//============================================================================================================
// Function wrapper
(function getCimWorkflowRoles() {

var debug=false;
//============================================================================================================
//Variable Declares
//============================================================================================================
	var cims=[''];
	if (cims.length == 0)
		cims=['courseadmin','programadmin'];
	var env='pvt';
	var version="6.0";
	var myName=arguments.callee.toString(); myName=myName.substr('function '.length); myName=myName.substr(0, myName.indexOf('('));

	var ignoreSteps = {
		"initiator":true,
		"regen": true,
		"addsisstep": true,
		"proposalstate": true,
		"annotate": true,
		"notifyallapprovers": true,
		"wflibversion": true,
		"checkondisk": true,
		"todo": true
	}

//============================================================================================================
//Headings
//============================================================================================================
	var header=[];;
	header.push("Step Version:" + version);
	header.push("");
	header.push("Instructions -- Please read before completing, if you have questions please contact your Client Services Manager");
	header.push("   1 - Please provide information for only those roles that will actually be active in the workflow.");
	header.push("       If a role is not going to be used in the workflow then please DELETE the line from the spreadsheet.");
	header.push("")
	header.push("   2 - Role Members -- Userids should be separated with commas, no blanks please.  If your institution uses user ID NUMBERS");
	header.push("       (UINs) as your login id then please specify the UIN for this data, failure to do so will result in a");
	header.push("       non-functional role.");
	header.push("")
	header.push("   3 - Email Override -- Note: This data field only applies to \'approver\' steps in the workflow, not \'fyi\' or \'fyiall\' steps.");
	header.push("       - Leave to blank to notify only the first individual in the userid list.");
	header.push("       - Set to \'all\' to notify all individuals in the userid list.  Note if the role has an \'fyiall\' directive");
	header.push("         then please do not specify all here.");
	header.push("       - Set to \'none\' to send out no notifications.");
	header.push("       - Otherwise the specified address will be used for emails for this role.  you only need to specify if you want");
	header.push("         Note: You should only need to specify if you want a different email than what would be normally used for the");
	header.push("         users in the role.  Please do not specify if you are NOT overriding the normal user email addresses.");
	header.push("")
	header.push("Notes:");
	header.push("   1) Data for college, department, and subject code values is pulled from the data provided in the CIM \'codes\' table.");
	header.push("   2) If any particular role is not going to be used (e.g. the department does not have a Chair),");
	header.push("      then please remove that line from this spreadsheet.");
	header.push("   3) If there is preexisting member data for a role it is added in below as a starting point.");
	header.push("   4) Order is alphabetic by step name before substitution.");
	header.push("   5) Roles below are a composite of all roles from work flows in: " + cims + ".");
	header.push("   6) Any user accounts listed in the roles are expected to be pre-provisioned and will not be created by the load script.");
	header.push("")
	header.push("Role Name\tRole Members (Comma separated userids)\tEmail Override (Please see above)\tSubstitution variables/values (FYI only, not used by workflow)");

//============================================================================================================
//# Helper Functions
//============================================================================================================
	function wfDump(varName,varValue){
		var myName=arguments.callee.toString(); myName=myName.substr('function '.length); myName=myName.substr(0, myName.indexOf('('));
		if (! debug) {return}
		// Set variables if this is not a full call
		if (varName === '') {
			var text='\n';
		} else {
			text=varName + ' = >' + varValue + '<\n';
		}
		print_doc(text);
	}

	function Here(id) {
		print_doc('Here ' + id + '\n');
	}

	function compare(a,b) {
	  if (a.stepData < b.stepData)
	    return -1;
	  if (a.stepData > b.stepData)
	    return 1;
	  return 0;
	}

	function RemoveDupes(arr,exclude) {
	    var noDupes=[];
	    exclude=' ' + exclude + ' ';
	    arr=arr.sort();
	    arr.forEach(function(value) {
			//if (typeof(wfDump) == "function") { var num=noDupes.indexOf(value); wfDump('\t\tIn Remove Dupes, index of ' + value + ' in input array',num); }
	        if ( noDupes.indexOf(value) == -1 && exclude.indexOf(' '+value+' ') < 0 ) {
	            noDupes.push(value);
	        }
	    });
	    return noDupes;
	}

//============================================================================================================
//# Hello
//============================================================================================================
if (debug) {print_doc('\n*** In ' + myName + ' ***\n');}

//============================================================================================================
//# Setup
//============================================================================================================
// Build a roles hash table from the data in roles.tcf
	var roles=[];
	var roleTcfData=[];
	var rolesHash={};
	var roleRec=[];
	var wfSubRules=[];
	var regex = new RegExp('^/courseleaf/roles.html$','i');
	if (! regex.test(tcfdata.pagename[0])) {
		if (debug) {print_doc('Loading Roles data from disk...\n'); }
		var roleTcfData = load_tcf("/courseleaf/roles.tcf");
		if (!roleTcfData) {
			addwarning('Cannot load roles.tcf');
			return false;
		}
		roles=roleTcfData.role;
	} else {
		roles=tcfdata.role
	}
	if (debug) {print_doc('\nFound ' + roles.length + ' roles in /courseleaf/roles.tcf.\n');}

	//Build roles hash table
	//roles.forEach(function(text) {
	//	roleRec=[]; roleRec.push(text.members); roleRec.push(text.email);
	//	rolesHash[text.name] = roleRec;
	//});

	roles.forEach(function(text) {
		roleRec={}; roleRec.members=text.members; roleRec.email=text.email;
		rolesHash[text.name] = roleRec;
	});

	if (debug) {
		print_doc('\nrolesHash table from roles.tcf:\n');
		for (var key in rolesHash) {
			print_doc('\trolesHash[' + key + '] = >' + rolesHash[key].toSource() + '<\n');
		}
	}

// get SIS name
var sisName='';
var cimconfigData = load_tcf('/courseadmin/cimconfig.cfg');
if (cimconfigData && cimconfigData.sisname) { sisName=cimconfigData.sisname[0] }
if (debug) { wfDump("sisName",sisName); }

// Add run info to the output
	print_doc('\n LEEPFROG INSTRUCTIONS \n');
	print_doc('\t' + myName + 'version: ' + version + '\n');
	print_doc('\t' + new Date() + '\n');

// Build a list of workflow steps from cims workflow.tcf files (see cims definition)
	print_doc('\n\tEnvironment: ' + env + '\n');
 	var idx, str, steps=[], conditionals=[], functions=[], tempArray=[], errorDetected=false, wfSubRulesHash=[], stepsHash=[];
	cims.forEach(function(cim) {
		var workflowTcfData = load_tcf('/' + cim + '/workflow.tcf');
		if (workflowTcfData) {
			print_doc('\t\tProcessing cim: ' + cim);

			//pull off list of conditional attributes from the localsteps data
				str=workflowTcfData.localsteps[0].params.replace('attributes=','');
				idx1=str.indexOf(";");
				str=str.substr(0,idx1);
				str.split(',').forEach(function(text) {
					idx1=text.indexOf("[");
					text=text.substr(0,idx1);
					conditionals.push(text);
				});//str.split
				if (debug) {print_doc("\nconditionals: " + conditionals.toSource() + "\n\n" );}

			//Get a list of workflow rules that are function calls
				var configTcfData=load_tcf('/' + cim + '/workflow.cfg');
				var wfrules=configTcfData["wfrules"];
				//print_doc("\nwfrules: " + wfrules.toSource() + "\n\n" );
				for (var key in wfrules) {
				    // skip loop if the property is from prototype
				    if (!wfrules.hasOwnProperty(key)) continue;
				    //var tmpObj = wfrules[key];
				    if (wfrules[key].type === "function" && wfrules[key].attrname != "wfAttr")
				    	functions.push(wfrules[key].searchfor)
				}
				if (debug) {print_doc("\nfunctions: " + functions.toSource() + "\n\n" );}

			//pull off workflow steps and add to master list
				workflows=workflowTcfData.workflow;
				workflows.forEach(function(text) {
					tempArray=[];
					tempArray = text.members.split(',');
					tempArray.forEach(function(step) {
						var tmpArray=step.split(" ");
						if (! ignoreSteps[tmpArray[0].toLowerCase()] ) {
							var tmpObj={};
							tmpObj.stepData=step;
							tmpObj.cimInstance=cim;
							steps.push(tmpObj);
						}
					});//steps
				});//workflows

			//retrieve the substitution variables, and get values from database
			var cimconfigTcfData = load_tcf('/' + cim + '/workflow.cfg');
			if (!cimconfigTcfData.wfSubRule || !cimconfigTcfData.wfSubRule.length) {
				cimconfigTcfData = load_tcf('/' + cim + '/cimconfig.cfg');
			}
			// Loop through wfSubRules data
			if (cimconfigTcfData) {
				print_doc('\n\tProcessing wfSubRules\n' );
				if (cimconfigTcfData.wfSubRule) {
					cimconfigTcfData.wfSubRule.forEach(function(text) {
						var idx1=text.indexOf("|");
						var subRuleName=text.substr(0,idx1);
						var subRuleText=text.substr(idx1+1);
						wfDump('\n\twfSubRule',text); wfDump('\t\tsubRuleName',subRuleName); wfDump('\t\tsubRuleText',subRuleText);
						// If we have already processed this rule then skip it
						if (wfSubRulesHash[subRuleName] != undefined) {
							print_doc("\t\t'" + subRuleName + "' already included above\n");
							return;
						}
						print_doc('\t\tsubRuleRule :' + subRuleText + '\n');
						// If rule is an enumeration then parse off and create an object array
						if (subRuleText.substr(0,1) === "[" ) {
							var tmpHashArray=[];
							var tmpStr=subRuleText.substr(1,subRuleText.length-2);
							var tmpArray=tmpStr.split(',');
							tmpArray.forEach(function(token) {
							var tmpObj={};
							var idx2=token.indexOf(":");
							if (idx2 > 0) {
								tmpObj.code=token.substr(1,idx2-1);
								tmpObj.name=token.substr(idx2+1,token.length-tmpObj.code.length-2);
							} else {
								tmpObj.code=token;
								tmpObj.name=token;
							}
							//tmpObj.origCode=tmpObj.code;
							tmpHashArray.push(tmpObj);
							});
							wfSubRulesHash[subRuleName]=tmpHashArray;
						// Otherwise assume rule is a sql query on the cimcodes table
						} else {
							wfSubRulesHash[subRuleName]=dbquery('cimcourses',text.substr(idx1+1));
						}

						// See if we have a mapper function for this variable
						var mapperFunctionName="Map" + subRuleName + "Val";
						mappedArray=[];
						wfSubRulesHash[subRuleName].forEach(function(token) {
							if (eval("typeof " + mapperFunctionName) === "function") {
								tmpObj={};
								eval("tmpObj.code="+ mapperFunctionName + "(\"" + token.code + "\")");
								tmpObj.name=token.name;
								tmpObj.origCode=token.code;
								mappedArray.push(tmpObj);
							} else {
								token.origCode=token.code
								mappedArray.push(token)
							}
						});//wfSubRulesHash[key].forEach
						wfSubRulesHash[subRuleName]=mappedArray

					}); // cimconfigTcfData.wfSubRule.forEach
				} else {
					print_doc('\n\t* Warning * -- could not find any wfSubRules defined in ' + cim + ' cimconfig.cfg file.\n\tStopping\n\n');
				}
			} else {
				print_doc('\n\t* Error * -- could not load /' + cim + '/cimconfig.cfg  or /workflow.cfg file.\n\tStopping\n\n');
				errorDetected=true;
			}
		}
	}); //cims.forEach(function(cim)

	if (debug) {
		print_doc('\n\nFound ' + Object.keys(wfSubRulesHash).length + ' subRules...\n');
		for (var i2=0,  tot=Object.keys(wfSubRulesHash).length; i2 < tot; i2++) {
			wfDump("\n\twfSubRulesHash[" + Object.keys(wfSubRulesHash)[i2] + "]",wfSubRulesHash[Object.keys(wfSubRulesHash)[i2]].toSource())
		}
		wfDump('');
	}

	if (errorDetected) {
		print_doc('\n*Error* --- Errors detected.\nStopping\n');
		return false;
	}

	// pre-process conditionals array to remove duplicates and then reverse order to take care of 'fyi' vs 'fyiall')
	conditionals.sort();
	conditionals=RemoveDupes(conditionals);
	conditionals.reverse();
	if (debug) {
		print_doc('Found ' + steps.length + ' steps...\n'); 
		steps.forEach(function(text) {
			print_doc('\tstep >' + text.toSource() + '<\n');
		});//steps
		print_doc('\n');
		print_doc('Found ' + conditionals.length + ' step conditionals...\n'); 
		conditionals.forEach(function(text) {
			print_doc('\tconditional >' + text.toSource() + '<\n');
		});//conditionals
		print_doc('\n');
	}
	// Pre-process the steps array: 1) remove the conditionals strings from the steps, 2)remove the steps that are function calls, 3) Combine cimInstance data for duplicate steps, 4) remove dups
		steps.sort(compare);
		for (var i=0,  tot=steps.length; i < tot; i++) {
			var stepData=steps[i].stepData
			if (stepData.indexOf("optional") > 0) {
				steps[i].optional=true;
				steps[i].cimInstance=steps[i].cimInstance + "/optional";
			}
			conditionals.forEach(function(conditional) {
				stepData=stepData.replace(conditional,'').trim();
			});
			steps[i].stepData=stepData;
			// functions
			for (var j=0,  tot2=functions.length; j < tot2; j++) {
				if (steps[i].stepData.indexOf(functions[j]) >= 0 && wfSubRulesHash[functions[j]] == undefined) {
					steps[i].stepData='' ; steps[i].cimInstance=''
					break;
				}
			}
		}
		// Remove empty records and duplicates
		var tmpArray=[], tmpStepData='', tmpStepDataPrev='', tmpInstancePrev='';
		for (var i=0,  tot=steps.length; i < tot; i++) {
			tmpStepData=steps[i].stepData
			if (steps[i].stepData === '') continue;
			if (tmpStepData === tmpStepDataPrev) {
				if (tmpArray[tmpArray.length - 1].cimInstance.indexOf(steps[i].cimInstance) < 0) {
					tmpArray[tmpArray.length - 1].cimInstance=tmpArray[tmpArray.length - 1].cimInstance + ", " + steps[i].cimInstance
				}
				continue;
			}
			tmpArray.push(steps[i]);
			tmpStepDataPrev=steps[i].stepData;
			tmpInstancePrev=steps[i].cimInstance;
		}
		steps=tmpArray;
		if (debug) {
			print_doc('\nFound ' + steps.length + ' steps...\n');
			print_doc('\nSteps after pre-processing:\n');
			steps.forEach(function(step) {
				print_doc('\tstep >' + step.toSource() + '<\n');
			});//steps
			print_doc('\n');
		}

//============================================================================================================
//# Main
//============================================================================================================
// Loop through the steps, substitute values and build initial output roles array

var rolesOut=steps;
var instanceData="";
var editString="";
var madeSubstitution=false;
var startLoopAt=0;

for (var i1=startLoopAt; i1 < rolesOut.length; i1++) {
	firstPassForThisStep=true;
	if (debug) { print_doc("rolesOut[" + i1 + "] = >" + rolesOut[i1].toSource() + "<\n"); }
	if (rolesOut[i1].stepData === "") continue
	editString=rolesOut[i1].stepData;
	instanceData=rolesOut[i1].cimInstance;
	variableData=rolesOut[i1].subVariables;
	madeSubstitution=false;
	for (var i2=0,  tot=Object.keys(wfSubRulesHash).length; i2 < tot; i2++) {
		key = Object.keys(wfSubRulesHash)[i2];
		re = new RegExp("\\b" + key + " |\\b" + key + "$", "g");
		//if (debug) { print_doc("\tkey: '" + key + "'\tre: '" + re + "'\n") }
		if (re.test(editString)) {
			madeSubstitution=true;
			if (debug) { print_doc("\t*** Substitute: '" + key + "' into '" + editString + "'\n"); }
			wfSubRulesHash[key].forEach(function(token) {
				if (typeof token.code === 'undefined') { var repString=token.name; } else { var repString=token.code; }
				editString=rolesOut[i1].stepData.replace(re,repString + " ");
					if (debug) { print_doc("\t   " + editString + "'\n"); }
					if (variableData === undefined) { 
						variableData=key; 
					} else {
						if (variableData.indexOf(key)<0) 
							variableData=variableData + ", " + key;
					}
				rolesOut.push({ stepData:editString, cimInstance:instanceData,subVariables:variableData }); // Add edited role string to the bottom of the array 
			}); //wfSubRulesHash[key].forEach
			rolesOut.splice(i1,1); i1--; //Remove the template role from rolesOut
		}
		if (madeSubstitution) break; //Only one substitution at a time
		//startLoopAt=i1;
	} //tot=Object.keys(wfSubRulesHash).length
} //tot=rolesOut.length

// Loop through the rolesOut array and add role member list and instance annotations
var haveStep=[];
rolesOut=rolesOut.sort();
for (var i1=0, tot=rolesOut.length; i1 < tot; i1++) {
	//If there are role members, then add to output string
	editString=rolesOut[i1].stepData;
	instanceData=rolesOut[i1].cimInstance;
	variableData=rolesOut[i1].subVariables;

	if (haveStep[editString] != undefined)
		continue;
	haveStep[editString]=true;
	
	if (rolesHash[editString] != undefined ) {
		//if (debug) { print_doc("\t\t\trolesHash["+str+"] = >" + rolesHash[str].toSource() + "<\n"); }
		editString=editString + "\t" + rolesHash[editString].members.toString() + "\t" + rolesHash[editString].email.toString() + "\t";
	} else {
		if (editString.indexOf("\t") < 0 ) { editString=editString + "\t\t\t" }
	}
	//Add the substituted variable info
	if (editString.indexOf("(") < 0 ) {
		rolesOut[i1]=editString + "(" +instanceData + " -- " + variableData + ")";
	} else {
		rolesOut[i1]=(editString + " (" + key.toLowerCase() + ":" + repString + ")");
	}
}

//Write the putput to stdout
// Header
print_doc('\n');
print_doc('CLIENT DATA');
print_doc('\n');
header.forEach(function(text) {
	print_doc(text + '\n');
});
// Roles
rolesOut=rolesOut.sort();
rolesOut.forEach(function(text) {
	if (typeof text === "string") print_doc(text + '\n');
});

return;

//============================================================================================================
//Close function wrapper
})();
%spidercode%